#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Copyright (c) 2025 Victor Lherm

All rights reserved.

This code is provided for academic and research purposes only. Any use of this code in published work or presentations must include a citation to the original author. Unauthorized copying, modification, or distribution of this code is prohibited without prior written permission from the author.

Computes the figures presented in "Magnetic Evolution of Super-Earth Exoplanets with a Basal Magma Ocean" by Lherm et al. (in prep.).

This script uses data contained in the subfolder "Data", that have been generated by running a simplified version of sweep.py on a relevant set of models.

Created by Victor Lherm on 2025-05-07 10:00:00.
"""

# %% Modules
# =============================================================================
import numpy as np
import matplotlib.pyplot as plt
import matplotlib as mpl
import dill as pkl

from scipy import integrate, ndimage
from scipy.constants import G, mu_0, R, k, N_A, eV

plt.style.use("main.mplstyle")

# %% Parameters
# =============================================================================
# Numerical flags
save_fig = True

# Paths
data_path = "Data"
save_path = "Figures"


# %% Functions
# =============================================================================
# Subplots label
def subplots_label(ax, colorbar=False, log=False):
    """
    Label subplots.

    """
    label = [chr(i) for i in range(ord("a"), ord("z") + 1)]

    if (colorbar == True) or (colorbar == False):
        colorbar = [colorbar] * ax.size

    if len(ax.shape) == 1:
        pad = [False] * ax.size
        for i in range(ax.size):
            if colorbar[i]:
                pad[i] = 48
            else:
                pad[i] = 6
    else:
        pad = [False] * ax.shape[0] * ax.shape[1]
        for i in range(ax.shape[0]):
            for j in range(ax.shape[1]):
                n = i * ax.shape[1] + j
                if colorbar[n]:
                    pad[n] = 48
                else:
                    pad[n] = 6

    if len(ax.shape) == 1:
        for i in range(ax.size):
            ax[i].set_title(
                "(%s)" % label[i],
                loc="left",
                fontsize="large",
                fontweight="bold",
                pad=pad[i],
            )
    else:
        for i in range(ax.shape[0]):
            for j in range(ax.shape[1]):
                n = i * ax.shape[1] + j
                ax[i, j].set_title(
                    "(%s)" % label[n],
                    loc="left",
                    fontsize="large",
                    fontweight="bold",
                    pad=pad[n],
                )

    if log:
        for i in range(ax.size):
            ax[i].get_yaxis().get_offset_text().set_position((-0.08, 0))

    return


# Colormaps
def viridis(N):
    colors = plt.cm.viridis(np.linspace(0, 1, N))
    return colors


def tab20(N):
    colors = plt.cm.tab20(np.linspace(0, 1, 20))[N]
    return colors


def tab20c(N):
    colors = plt.cm.tab20c(np.linspace(0, 1, 20))[N]
    return colors


# Linestyles
def line_styles(N):
    style = ["-", "--", "-.", ":"]
    return style[N]


# %% Load data
# =============================================================================
# Functions
from functions import (
    N,
    s2y,
    eta_solid,
    psi_eta,
    theta_eta,
)

# M
with open("{:s}/sw_M.pkl".format(data_path), "rb") as f:
    SW_M = pkl.load(f)

CMF_M = np.array([0.2, 0.32, 0.68])

# CMF
with open("{:s}/sw_CMF.pkl".format(data_path), "rb") as f:
    SW_CMF = pkl.load(f)

M_CMF = np.linspace(1, 10, 10)

# %% PREM model (Dziewonski & Anderson, 1981)
# ==============================================================================
# Radius
zero = 1e-12
r_PREM = np.linspace(0, 6371e3, N)


# Density
def PREM_density(radius, R_earth=6371e3):
    if isinstance(radius, (int, float)):
        radius = np.array([radius])
    rho = np.zeros(len(radius))

    idx = np.argwhere(radius <= 1221.5e3)
    x = radius[idx] / R_earth
    rho[idx] = 13.0885 - 8.8381 * x**2
    idx = np.argwhere((radius > 1221.5e3) & (radius <= 3480e3))
    x = radius[idx] / R_earth
    rho[idx] = 12.5815 - 1.2638 * x - 3.6426 * x**2 - 5.5281 * x**3
    idx = np.argwhere((radius > 3480e3) & (radius <= 5701e3))
    x = radius[idx] / R_earth
    rho[idx] = 7.9565 - 6.4761 * x + 5.5283 * x**2 - 3.0807 * x**3
    idx = np.argwhere((radius > 5701e3) & (radius <= 5771e3))
    x = radius[idx] / R_earth
    rho[idx] = 5.3197 - 1.4836 * x
    idx = np.argwhere((radius > 5771e3) & (radius <= 5971e3))
    x = radius[idx] / R_earth
    rho[idx] = 11.2494 - 8.0298 * x
    idx = np.argwhere((radius > 5971e3) & (radius <= 6151e3))
    x = radius[idx] / R_earth
    rho[idx] = 7.1089 - 3.8045 * x
    idx = np.argwhere((radius > 6151e3) & (radius <= 6346.6e3))
    x = radius[idx] / R_earth
    rho[idx] = 2.6910 + 0.6924 * x
    idx = np.argwhere((radius > 6346.6e3) & (radius <= 6356e3))
    x = radius[idx] / R_earth
    rho[idx] = 2.9000
    idx = np.argwhere((radius > 6356e3) & (radius <= 6368e3))
    x = radius[idx] / R_earth
    rho[idx] = 2.6000
    idx = np.argwhere((radius > 6368e3) & (radius <= R_earth))
    x = radius[idx] / R_earth
    rho[idx] = 2.6000

    if len(radius) == 1:
        rho = rho[0]
    return rho * 1e3


# Mass distribution
def PREM_mass(radius):
    if isinstance(radius, (int, float)):
        radius = np.array([radius])
    r = radius.copy()
    if r[0] == 0:
        r[0] = zero
    r_trapz = np.linspace(zero, r[0], N)
    m0 = integrate.trapezoid(r_trapz**2 * PREM_density(r_trapz), r_trapz)
    if len(r) > 1:
        m = (4 * np.pi) * (
            m0 + integrate.cumulative_trapezoid(r**2 * PREM_density(r), r, initial=0)
        )
    else:
        m = (4 * np.pi) * m0
    return m


# Gravity
def PREM_gravity(radius):
    if isinstance(radius, (int, float)):
        radius = np.array([radius])
    r = radius.copy()
    if r[0] == 0:
        r[0] = zero
    r_trapz = np.linspace(zero, r[0], N)
    g0 = integrate.trapezoid(r_trapz**2 * PREM_density(r_trapz), r_trapz)
    if len(r) > 1:
        g = (4 * np.pi * G / r**2) * (
            g0 + integrate.cumulative_trapezoid(r**2 * PREM_density(r), r, initial=0)
        )
    else:
        g = (4 * np.pi * G / r[0] ** 2) * g0
    return g


# Gravitational potential
def PREM_gravi_potential(radius, R0=3480e3):
    if isinstance(radius, (int, float)):
        radius = np.array([radius])
    r_trapz = np.linspace(radius[-1], R0, N)
    psi_0 = -integrate.trapezoid(PREM_gravity(r_trapz), r_trapz)
    if len(radius) > 1:
        psi = psi_0 + np.flip(
            integrate.cumulative_trapezoid(
                np.flip(PREM_gravity(radius)), np.flip(radius), initial=0
            )
        )
    else:
        psi = psi_0
    return psi


# Pressure
def PREM_pressure(radius, R0=6371e3, P0=1.01325e5):
    if isinstance(radius, (int, float)):
        radius = np.array([radius])
    r = radius.copy()
    if r[0] == 0:
        r[0] = zero

    if len(r) > 1:
        P = np.zeros(len(r))

        idx = np.argwhere(r < R0).T[0]
        if len(idx) > 0:
            rd = r[idx]
            P[idx] = P0 + np.flip(
                integrate.cumulative_trapezoid(
                    -np.flip(PREM_density(rd)) * np.flip(PREM_gravity(rd)),
                    np.flip(rd),
                    initial=0,
                )
            )
            if r[0] != 0:
                r_trapz = np.linspace(rd[-1], R0, N)
                P[idx] += integrate.trapezoid(
                    PREM_density(r_trapz) * PREM_gravity(r_trapz), r_trapz
                )

        idx = np.argwhere(r > R0).T[0]
        if len(idx) > 0:
            rd = r[idx]
            P[idx] = P0 + integrate.cumulative_trapezoid(
                -PREM_density(rd) * PREM_gravity(rd),
                rd,
                initial=0,
            )
            if r[-1] != R0:
                r_trapz = np.linspace(R0, rd[0], N)
                P[idx] += integrate.trapezoid(
                    -PREM_density(r_trapz) * PREM_gravity(r_trapz), r_trapz
                )

        idx = np.argwhere(r == R0).T[0]
        if len(idx) > 0:
            r_trapz = np.linspace(r[0], R0, N)
            P[idx] = P0

    else:
        if r[0] <= R0:
            r_trapz = np.linspace(r[0], R0, N)
            P = P0 + integrate.trapezoid(
                PREM_density(r_trapz) * PREM_gravity(r_trapz), r_trapz
            )
        else:
            r_trapz = np.linspace(R0, r[0], N)
            P = P0 + integrate.trapezoid(
                -PREM_density(r_trapz) * PREM_gravity(r_trapz), r_trapz
            )
    return P


# %% Pre-processing
# =============================================================================
# Crystallisation of the BMO
i_BMO_M, t_BMO_M, mask_BMO_M = [np.zeros(len(SW_M), dtype=object) for _ in range(3)]
for n in range(len(SW_M)):
    i_BMO_M_n = np.zeros(len(SW_M[n].sw_val), dtype=int)
    t_BMO_M_n = np.zeros(len(SW_M[n].sw_val), dtype=float)
    mask_BMO_M_n = np.zeros(len(SW_M[n].sw_val), dtype=object)
    for m in range(len(SW_M[n].sw_val)):
        mask_BMO_M_n[m] = np.zeros(len(SW_M[n].t[m]), dtype=bool)
        try:
            i_BMO_M_n[m] = np.nanargmin(np.abs(SW_M[n].T_CMB[m] - SW_M[n].T_BMO[m] - 1))
            t_BMO_M_n[m] = SW_M[n].t[m][i_BMO_M_n[m]]
            mask_BMO_M_n[m][: i_BMO_M_n[m]] = True
        except:
            i_BMO_M_n[m] = -1
            t_BMO_M_n[m] = np.nan

    i_BMO_M[n] = i_BMO_M_n
    t_BMO_M[n] = t_BMO_M_n
    mask_BMO_M[n] = mask_BMO_M_n

i_BMO_CMF, t_BMO_CMF, mask_BMO_CMF = [
    np.zeros(len(SW_CMF), dtype=object) for _ in range(3)
]
for n in range(len(SW_CMF)):
    i_BMO_CMF_n = np.zeros(len(SW_CMF[n].sw_val), dtype=int)
    t_BMO_CMF_n = np.zeros(len(SW_CMF[n].sw_val), dtype=float)
    mask_BMO_CMF_n = np.zeros(len(SW_CMF[n].sw_val), dtype=object)
    for m in range(len(SW_CMF[n].sw_val)):
        mask_BMO_CMF_n[m] = np.zeros(len(SW_CMF[n].t[m]), dtype=bool)
        try:
            i_BMO_CMF_n[m] = np.nanargmin(
                np.abs(SW_CMF[n].T_CMB[m] - SW_CMF[n].T_BMO[m] - 1)
            )
            t_BMO_CMF_n[m] = SW_CMF[n].t[m][i_BMO_CMF_n[m]]
            mask_BMO_CMF_n[m][: i_BMO_CMF_n[m]] = True
        except:
            i_BMO_CMF_n[m] = -1
            t_BMO_CMF_n[m] = np.nan

    i_BMO_CMF[n] = i_BMO_CMF_n
    t_BMO_CMF[n] = t_BMO_CMF_n
    mask_BMO_CMF[n] = mask_BMO_CMF_n

# Crystallisaiton of the core
is_ICN_0_M = np.zeros((len(SW_M[0].sw_val), len(CMF_M)), dtype=bool)
for n in range(is_ICN_0_M.shape[1]):
    for m in range(is_ICN_0_M.shape[0]):
        is_ICN_0_M[m, n] = ~np.isnan(SW_M[n].R_ICB[m][0])

is_ICN_0_CMF = np.zeros((len(M_CMF), len(SW_CMF[0].sw_val)), dtype=bool)
for n in range(is_ICN_0_CMF.shape[0]):
    for m in range(is_ICN_0_CMF.shape[1]):
        is_ICN_0_CMF[n, m] = ~np.isnan(SW_CMF[n].R_ICB[m][0])

# %% Main: Evolution (M + CMF)
# =============================================================================
fig, ax = plt.subplots(2, 2, figsize=(8, 6), sharex=True)

n, j = 1, 0

i_time = np.argwhere(~np.isnan(SW_M[n].t)[:, 0]).flatten()[0]
t_m, sw_val_m = np.meshgrid(SW_M[n].t[i_time], SW_M[n].sw_val)

mask_BMO = np.zeros((len(SW_M[n].sw_val), len(SW_M[n].t[i_time])))
for i in range(len(SW_M[n].sw_val)):
    mask_BMO[i] = np.where(SW_M[n].t[i] < t_BMO_M[n][i], 1, np.nan)

i = 0
p = ax[i, j].pcolormesh(
    s2y(SW_M[n].t[i_time]) / 1e9,
    SW_M[n].sw_val,
    SW_M[n].L_BMO * mask_BMO / 1e3,
    cmap="inferno_r",
    shading="auto",
    vmin=0,
    rasterized=True,
)

idx_BMO = np.zeros(len(SW_M[n].sw_val), dtype=object)
for m in range(len(SW_M[n].sw_val)):
    idx_BMO[m] = np.argwhere(
        np.abs(
            np.diff(
                np.sign((SW_M[n].Q_BMO[m] - SW_M[n].Q_A_BMO_S2020[m]) * mask_BMO[m])
            )
        )
        > 0
    ).flatten()


for m in range(len(SW_M[n].sw_val)):
    if m < len(SW_M[n].sw_val) - 1:
        hw_p = (SW_M[n].sw_val[m + 1] - SW_M[n].sw_val[m]) / 2
    else:
        hw_p = (SW_M[n].sw_val[m] - SW_M[n].sw_val[m - 1]) / 2
    if m > 0:
        hw_m = (SW_M[n].sw_val[m] - SW_M[n].sw_val[m - 1]) / 2
    else:
        hw_m = (SW_M[n].sw_val[m + 1] - SW_M[n].sw_val[m]) / 2

    for l in range(len(idx_BMO[m])):
        if l == 0:
            rec = mpl.patches.Rectangle(
                (
                    s2y(SW_M[n].t[i_time])[0] / 1e9,
                    SW_M[n].sw_val[m] - hw_m,
                ),
                (s2y(SW_M[n].t[i_time])[idx_BMO[m][l]] - s2y(SW_M[n].t[i_time])[0])
                / 1e9,
                hw_m + hw_p,
                edgecolor="lime",
                facecolor="none",
                linewidth=1.5,
                zorder=10,
            )
        elif l == len(idx_BMO[m]) - 1:
            rec = mpl.patches.Rectangle(
                (
                    s2y(SW_M[n].t[i_time])[idx_BMO[m][l]] / 1e9,
                    SW_M[n].sw_val[m] - hw_m,
                ),
                (s2y(SW_M[n].t[i_time])[-1] - s2y(SW_M[n].t[i_time])[idx_BMO[m][l]])
                / 1e9,
                hw_m + hw_p,
                edgecolor="lime",
                facecolor="none",
                linewidth=1.5,
                zorder=10,
            )

        ax[i, j].add_patch(rec)

idx_BMO = np.zeros(len(SW_M[n].sw_val), dtype=object)
for m in range(len(SW_M[n].sw_val)):
    idx_BMO[m] = np.argwhere(
        np.abs(
            np.diff(
                np.sign((SW_M[n].mask_dC0dr_TOT_BMO_S2020[m] - 0.005) * mask_BMO[m])
            )
        )
        > 0
    ).flatten()

for m in range(len(SW_M[n].sw_val)):
    if m < len(SW_M[n].sw_val) - 1:
        hw_p = (SW_M[n].sw_val[m + 1] - SW_M[n].sw_val[m]) / 2
    else:
        hw_p = (SW_M[n].sw_val[m] - SW_M[n].sw_val[m - 1]) / 2
    if m > 0:
        hw_m = (SW_M[n].sw_val[m] - SW_M[n].sw_val[m - 1]) / 2
    else:
        hw_m = (SW_M[n].sw_val[m + 1] - SW_M[n].sw_val[m]) / 2

    for l in range(len(idx_BMO[m])):
        if l == 0:
            rec = mpl.patches.Rectangle(
                (
                    s2y(SW_M[n].t[i_time])[0] / 1e9,
                    SW_M[n].sw_val[m] - hw_m,
                ),
                (s2y(SW_M[n].t[i_time])[idx_BMO[m][l]] - s2y(SW_M[n].t[i_time])[0])
                / 1e9,
                hw_m + hw_p,
                edgecolor="lime",
                facecolor="none",
                hatch="///",
                linewidth=1.5,
                zorder=10,
            )
        elif l == len(idx_BMO[m]) - 1:
            rec = mpl.patches.Rectangle(
                (
                    s2y(SW_M[n].t[i_time])[idx_BMO[m][l]] / 1e9,
                    SW_M[n].sw_val[m] - hw_m,
                ),
                (s2y(SW_M[n].t[i_time])[-1] - s2y(SW_M[n].t[i_time])[idx_BMO[m][l]])
                / 1e9,
                hw_m + hw_p,
                edgecolor="lime",
                facecolor="none",
                hatch="///",
                linewidth=1.5,
                zorder=10,
            )

        ax[i, j].add_patch(rec)

cb = fig.colorbar(
    p,
    ax=ax[i, j],
    location="right",
)
cb.ax.set_title("$L_b$ (km)", loc="left", fontsize=10, pad=8)

ax[i, j].set_ylabel("$M_P/M_{\\oplus}$")
ax[i, j].set_title("$\\mathrm{CMF}= $" + "${:.2f}$".format(CMF_M[n]))
ax[i, j].set_yticks(SW_M[n].sw_val)
ax[i, j].set_yticklabels(SW_M[n].sw_val.astype(int))

handles = [
    mpl.patches.Rectangle(
        (0, 0),
        1,
        1,
        edgecolor="lime",
        facecolor="none",
    ),
    mpl.patches.Patch(
        facecolor="none",
        edgecolor="lime",
        hatch="///",
    ),
]
labels = ["$Q_{BMO} < Q_{A,b}$", "$q_b \geq 0$"]
ax[i, j].legend(handles, labels, loc="lower right", fontsize="small")

mask_OC = np.where(SW_M[n].L_OC > 0, 1, np.nan)

i = 1
p = ax[i, j].pcolormesh(
    s2y(SW_M[n].t[i_time]) / 1e9,
    SW_M[n].sw_val,
    SW_M[n].L_OC * mask_OC / 1e3,
    cmap="inferno_r",
    shading="auto",
    vmin=0,
    rasterized=True,
)

idx_core = np.zeros(len(SW_M[n].sw_val), dtype=object)
for m in range(len(SW_M[n].sw_val)):
    idx_core[m] = np.argwhere(
        np.abs(np.diff(np.sign((SW_M[n].Q_CMB[m] - SW_M[n].Q_A_core[m]) * mask_OC[m])))
        > 0
    ).flatten()


for m in range(len(SW_M[n].sw_val)):
    if m < len(SW_M[n].sw_val) - 1:
        hw_p = (SW_M[n].sw_val[m + 1] - SW_M[n].sw_val[m]) / 2
    else:
        hw_p = (SW_M[n].sw_val[m] - SW_M[n].sw_val[m - 1]) / 2
    if m > 0:
        hw_m = (SW_M[n].sw_val[m] - SW_M[n].sw_val[m - 1]) / 2
    else:
        hw_m = (SW_M[n].sw_val[m + 1] - SW_M[n].sw_val[m]) / 2

    for l in range(len(idx_core[m])):
        if l == 0:
            rec = mpl.patches.Rectangle(
                (
                    s2y(SW_M[n].t[i_time])[0] / 1e9,
                    SW_M[n].sw_val[m] - hw_m,
                ),
                (s2y(SW_M[n].t[i_time])[idx_core[m][l]] - s2y(SW_M[n].t[i_time])[0])
                / 1e9,
                hw_m + hw_p,
                edgecolor="lime",
                facecolor="none",
                linewidth=1.5,
                zorder=10,
            )
        elif l == len(idx_core[m]) - 1:
            if np.any(np.isnan(mask_OC[m])):
                idx_end = np.argwhere(~np.isnan(mask_OC[m])).flatten()[-1]
            else:
                idx_end = -1

            rec = mpl.patches.Rectangle(
                (
                    s2y(SW_M[n].t[i_time])[idx_core[m][l]] / 1e9,
                    SW_M[n].sw_val[m] - hw_m,
                ),
                (
                    s2y(SW_M[n].t[i_time])[idx_end]
                    - s2y(SW_M[n].t[i_time])[idx_core[m][l]]
                )
                / 1e9,
                hw_m + hw_p,
                edgecolor="lime",
                facecolor="none",
                linewidth=1.5,
                zorder=10,
            )

        ax[i, j].add_patch(rec)

idx_core = np.zeros(len(SW_M[n].sw_val), dtype=object)
for m in range(len(SW_M[n].sw_val)):
    idx_core[m] = np.argwhere(
        np.abs(np.diff(np.sign((SW_M[n].mask_dC0dr_TOT_core[m] - 0.005) * mask_OC[m])))
        > 0
    ).flatten()

for m in range(len(SW_M[n].sw_val)):
    if m < len(SW_M[n].sw_val) - 1:
        hw_p = (SW_M[n].sw_val[m + 1] - SW_M[n].sw_val[m]) / 2
    else:
        hw_p = (SW_M[n].sw_val[m] - SW_M[n].sw_val[m - 1]) / 2
    if m > 0:
        hw_m = (SW_M[n].sw_val[m] - SW_M[n].sw_val[m - 1]) / 2
    else:
        hw_m = (SW_M[n].sw_val[m + 1] - SW_M[n].sw_val[m]) / 2

    for l in range(len(idx_core[m])):
        if l == 0:
            rec = mpl.patches.Rectangle(
                (
                    s2y(SW_M[n].t[i_time])[0] / 1e9,
                    SW_M[n].sw_val[m] - hw_m,
                ),
                (s2y(SW_M[n].t[i_time])[idx_core[m][l]] - s2y(SW_M[n].t[i_time])[0])
                / 1e9,
                hw_m + hw_p,
                edgecolor="lime",
                facecolor="none",
                hatch="///",
                linewidth=1.5,
                zorder=10,
            )
        elif l == len(idx_core[m]) - 1:
            if np.any(np.isnan(mask_OC[m])):
                idx_end = np.argwhere(~np.isnan(mask_OC[m])).flatten()[-1]
            else:
                idx_end = -1

            rec = mpl.patches.Rectangle(
                (
                    s2y(SW_M[n].t[i_time])[idx_core[m][l]] / 1e9,
                    SW_M[n].sw_val[m] - hw_m,
                ),
                (
                    s2y(SW_M[n].t[i_time])[idx_end]
                    - s2y(SW_M[n].t[i_time])[idx_core[m][l]]
                )
                / 1e9,
                hw_m + hw_p,
                edgecolor="lime",
                facecolor="none",
                hatch="///",
                linewidth=1.5,
                zorder=10,
            )

        ax[i, j].add_patch(rec)

idx = np.zeros(len(SW_M[n].sw_val), dtype=object)
for m in range(len(SW_M[n].sw_val)):
    idx[m] = np.argwhere(~np.isnan(SW_M[n].R_ICB[m])).flatten()[0]
    if idx[m] > 0:
        if m < len(SW_M[n].sw_val) - 1:
            hw_p = (SW_M[n].sw_val[m + 1] - SW_M[n].sw_val[m]) / 2
        else:
            hw_p = (SW_M[n].sw_val[m] - SW_M[n].sw_val[m - 1]) / 2
        if m > 0:
            hw_m = (SW_M[n].sw_val[m] - SW_M[n].sw_val[m - 1]) / 2
        else:
            hw_m = (SW_M[n].sw_val[m + 1] - SW_M[n].sw_val[m]) / 2

        ax[i, j].plot(
            np.array([s2y(SW_M[n].t[i_time])[idx[m]] / 1e9] * 2),
            np.array([SW_M[n].sw_val[m]] * 2) + [-hw_m, +hw_p],
            ":.",
            color="red",
            linewidth=2,
            zorder=20,
        )

cb = fig.colorbar(
    p,
    ax=ax[i, j],
    location="right",
)
cb.ax.set_title("$L_c$ (km)", loc="left", fontsize=10, pad=8)

ax[i, j].set_xlabel("$t$ (Gyr)")
ax[i, j].set_ylabel("$M_P/M_{\\oplus}$")
ax[i, j].set_yticks(SW_M[n].sw_val)
ax[i, j].set_yticklabels(SW_M[n].sw_val.astype(int))

handles = [
    mpl.patches.Rectangle(
        (0, 0),
        1,
        1,
        edgecolor="lime",
        facecolor="none",
    ),
    mpl.patches.Patch(
        facecolor="none",
        edgecolor="lime",
        hatch="///",
    ),
    mpl.lines.Line2D([0], [0], linestyle=":", color="red"),
]
labels = ["$Q_{CMB} < Q_{A,c}$", "$q_c \geq 0$", "ICN"]
ax[i, j].legend(handles, labels, loc="center right", fontsize="small")

n, j = 3, 1

i_time = np.argwhere(~np.isnan(SW_CMF[n].t)[:, 0]).flatten()[0]
t_m, sw_val_m = np.meshgrid(SW_CMF[n].t[i_time], SW_CMF[n].sw_val)

mask_BMO = np.zeros((len(SW_CMF[n].sw_val), len(SW_CMF[n].t[i_time])))
for i in range(len(SW_CMF[n].sw_val)):
    mask_BMO[i] = np.where(SW_CMF[n].t[i] < t_BMO_CMF[n][i], 1, np.nan)

i = 0
p = ax[i, j].pcolormesh(
    s2y(SW_CMF[n].t[i_time]) / 1e9,
    SW_CMF[n].sw_val,
    SW_CMF[n].L_BMO * mask_BMO / 1e3,
    cmap="inferno_r",
    shading="auto",
    vmin=0,
    rasterized=True,
)

idx_BMO = np.zeros(len(SW_CMF[n].sw_val), dtype=object)
for m in range(len(SW_CMF[n].sw_val)):
    idx_BMO[m] = np.argwhere(
        np.abs(
            np.diff(
                np.sign((SW_CMF[n].Q_BMO[m] - SW_CMF[n].Q_A_BMO_S2020[m]) * mask_BMO[m])
            )
        )
        > 0
    ).flatten()

for m in range(len(SW_CMF[n].sw_val)):
    if m < len(SW_CMF[n].sw_val) - 1:
        hw_p = (SW_CMF[n].sw_val[m + 1] - SW_CMF[n].sw_val[m]) / 2
    else:
        hw_p = (SW_CMF[n].sw_val[m] - SW_CMF[n].sw_val[m - 1]) / 2
    if m > 0:
        hw_m = (SW_CMF[n].sw_val[m] - SW_CMF[n].sw_val[m - 1]) / 2
    else:
        hw_m = (SW_CMF[n].sw_val[m + 1] - SW_CMF[n].sw_val[m]) / 2

    for l in range(len(idx_BMO[m])):
        if l == 0:
            rec = mpl.patches.Rectangle(
                (
                    s2y(SW_CMF[n].t[i_time])[0] / 1e9,
                    SW_CMF[n].sw_val[m] - hw_m,
                ),
                (s2y(SW_CMF[n].t[i_time])[idx_BMO[m][l]] - s2y(SW_CMF[n].t[i_time])[0])
                / 1e9,
                hw_m + hw_p,
                edgecolor="lime",
                facecolor="none",
                linewidth=1.5,
                zorder=10,
            )
        elif l == len(idx_BMO[m]) - 1:
            rec = mpl.patches.Rectangle(
                (
                    s2y(SW_CMF[n].t[i_time])[idx_BMO[m][l]] / 1e9,
                    SW_CMF[n].sw_val[m] - hw_m,
                ),
                (s2y(SW_CMF[n].t[i_time])[-1] - s2y(SW_CMF[n].t[i_time])[idx_BMO[m][l]])
                / 1e9,
                hw_m + hw_p,
                edgecolor="lime",
                facecolor="none",
                linewidth=1.5,
                zorder=10,
            )

        ax[i, j].add_patch(rec)

idx_BMO = np.zeros(len(SW_CMF[n].sw_val), dtype=object)
for m in range(len(SW_CMF[n].sw_val)):
    idx_BMO[m] = np.argwhere(
        np.abs(
            np.diff(
                np.sign((SW_CMF[n].mask_dC0dr_TOT_BMO_S2020[m] - 0.005) * mask_BMO[m])
            )
        )
        > 0
    ).flatten()

for m in range(len(SW_CMF[n].sw_val)):
    if m < len(SW_CMF[n].sw_val) - 1:
        hw_p = (SW_CMF[n].sw_val[m + 1] - SW_CMF[n].sw_val[m]) / 2
    else:
        hw_p = (SW_CMF[n].sw_val[m] - SW_CMF[n].sw_val[m - 1]) / 2
    if m > 0:
        hw_m = (SW_CMF[n].sw_val[m] - SW_CMF[n].sw_val[m - 1]) / 2
    else:
        hw_m = (SW_CMF[n].sw_val[m + 1] - SW_CMF[n].sw_val[m]) / 2

    for l in range(len(idx_BMO[m])):
        if l == 0:
            rec = mpl.patches.Rectangle(
                (
                    s2y(SW_CMF[n].t[i_time])[0] / 1e9,
                    SW_CMF[n].sw_val[m] - hw_m,
                ),
                (s2y(SW_CMF[n].t[i_time])[idx_BMO[m][l]] - s2y(SW_CMF[n].t[i_time])[0])
                / 1e9,
                hw_m + hw_p,
                edgecolor="lime",
                facecolor="none",
                hatch="///",
                linewidth=1.5,
                zorder=10,
            )
        elif l == len(idx_BMO[m]) - 1:
            rec = mpl.patches.Rectangle(
                (
                    s2y(SW_CMF[n].t[i_time])[idx_BMO[m][l]] / 1e9,
                    SW_CMF[n].sw_val[m] - hw_m,
                ),
                (s2y(SW_CMF[n].t[i_time])[-1] - s2y(SW_CMF[n].t[i_time])[idx_BMO[m][l]])
                / 1e9,
                hw_m + hw_p,
                edgecolor="lime",
                facecolor="none",
                hatch="///",
                linewidth=1.5,
                zorder=10,
            )

        ax[i, j].add_patch(rec)

cb = fig.colorbar(
    p,
    ax=ax[i, j],
    location="right",
)
cb.ax.set_title("$L_b$ (km)", loc="left", fontsize=10, pad=8)

ax[i, j].set_ylabel("CMF")
ax[i, j].set_title("$M_P={:.0f}$ ".format(M_CMF[n]) + "$M_{\\oplus}$")
ax[i, j].set_yticks(SW_CMF[n].sw_val)
ax[i, j].set_yticklabels(SW_CMF[n].sw_val)

handles = [
    mpl.patches.Rectangle(
        (0, 0),
        1,
        1,
        edgecolor="lime",
        facecolor="none",
    ),
    mpl.patches.Patch(
        facecolor="none",
        edgecolor="lime",
        hatch="///",
    ),
]
labels = ["$Q_{BMO} < Q_{A,b}$", "$q_b \geq 0$"]
ax[i, j].legend(handles, labels, loc="lower right", fontsize="small")

mask_OC = np.where(SW_CMF[n].L_OC > 0, 1, np.nan)

i = 1
p = ax[i, j].pcolormesh(
    s2y(SW_CMF[n].t[i_time]) / 1e9,
    SW_CMF[n].sw_val,
    SW_CMF[n].L_OC * mask_OC / 1e3,
    cmap="inferno_r",
    shading="auto",
    vmin=0,
    rasterized=True,
)

idx_core = np.zeros(len(SW_CMF[n].sw_val), dtype=object)
for m in range(len(SW_CMF[n].sw_val)):
    idx_core[m] = np.argwhere(
        np.abs(
            np.diff(np.sign((SW_CMF[n].Q_CMB[m] - SW_CMF[n].Q_A_core[m]) * mask_OC[m]))
        )
        > 0
    ).flatten()

for m in range(len(SW_CMF[n].sw_val)):
    if m < len(SW_CMF[n].sw_val) - 1:
        hw_p = (SW_CMF[n].sw_val[m + 1] - SW_CMF[n].sw_val[m]) / 2
    else:
        hw_p = (SW_CMF[n].sw_val[m] - SW_CMF[n].sw_val[m - 1]) / 2
    if m > 0:
        hw_m = (SW_CMF[n].sw_val[m] - SW_CMF[n].sw_val[m - 1]) / 2
    else:
        hw_m = (SW_CMF[n].sw_val[m + 1] - SW_CMF[n].sw_val[m]) / 2

    for l in range(len(idx_core[m])):
        if l == 0:
            rec = mpl.patches.Rectangle(
                (
                    s2y(SW_CMF[n].t[i_time])[0] / 1e9,
                    SW_CMF[n].sw_val[m] - hw_m,
                ),
                (s2y(SW_CMF[n].t[i_time])[idx_core[m][l]] - s2y(SW_CMF[n].t[i_time])[0])
                / 1e9,
                hw_m + hw_p,
                edgecolor="lime",
                facecolor="none",
                linewidth=1.5,
                zorder=10,
            )
        elif l == len(idx_core[m]) - 1:
            if np.any(np.isnan(mask_OC[m])):
                idx_end = np.argwhere(~np.isnan(mask_OC[m])).flatten()[-1]
            else:
                idx_end = -1

            rec = mpl.patches.Rectangle(
                (
                    s2y(SW_CMF[n].t[i_time])[idx_core[m][l]] / 1e9,
                    SW_CMF[n].sw_val[m] - hw_m,
                ),
                (
                    s2y(SW_CMF[n].t[i_time])[idx_end]
                    - s2y(SW_CMF[n].t[i_time])[idx_core[m][l]]
                )
                / 1e9,
                hw_m + hw_p,
                edgecolor="lime",
                facecolor="none",
                linewidth=1.5,
                zorder=10,
            )

        ax[i, j].add_patch(rec)

idx_core = np.zeros(len(SW_CMF[n].sw_val), dtype=object)
for m in range(len(SW_CMF[n].sw_val)):
    idx_core[m] = np.argwhere(
        np.abs(
            np.diff(np.sign((SW_CMF[n].mask_dC0dr_TOT_core[m] - 0.005) * mask_OC[m]))
        )
        > 0
    ).flatten()

for m in range(len(SW_CMF[n].sw_val)):
    if m < len(SW_CMF[n].sw_val) - 1:
        hw_p = (SW_CMF[n].sw_val[m + 1] - SW_CMF[n].sw_val[m]) / 2
    else:
        hw_p = (SW_CMF[n].sw_val[m] - SW_CMF[n].sw_val[m - 1]) / 2
    if m > 0:
        hw_m = (SW_CMF[n].sw_val[m] - SW_CMF[n].sw_val[m - 1]) / 2
    else:
        hw_m = (SW_CMF[n].sw_val[m + 1] - SW_CMF[n].sw_val[m]) / 2

    for l in range(len(idx_core[m])):
        if l == 0:
            rec = mpl.patches.Rectangle(
                (
                    s2y(SW_CMF[n].t[i_time])[0] / 1e9,
                    SW_CMF[n].sw_val[m] - hw_m,
                ),
                (s2y(SW_CMF[n].t[i_time])[idx_core[m][l]] - s2y(SW_CMF[n].t[i_time])[0])
                / 1e9,
                hw_m + hw_p,
                edgecolor="lime",
                facecolor="none",
                hatch="///",
                linewidth=1.5,
                zorder=10,
            )
        elif l == len(idx_core[m]) - 1:
            if np.any(np.isnan(mask_OC[m])):
                idx_end = np.argwhere(~np.isnan(mask_OC[m])).flatten()[-1]
            else:
                idx_end = -1

            rec = mpl.patches.Rectangle(
                (
                    s2y(SW_CMF[n].t[i_time])[idx_core[m][l]] / 1e9,
                    SW_CMF[n].sw_val[m] - hw_m,
                ),
                (
                    s2y(SW_CMF[n].t[i_time])[idx_end]
                    - s2y(SW_CMF[n].t[i_time])[idx_core[m][l]]
                )
                / 1e9,
                hw_m + hw_p,
                edgecolor="lime",
                facecolor="none",
                hatch="///",
                linewidth=1.5,
                zorder=10,
            )

        ax[i, j].add_patch(rec)

idx = np.zeros(len(SW_CMF[n].sw_val), dtype=object)
for m in range(len(SW_CMF[n].sw_val)):
    idx[m] = np.argwhere(~np.isnan(SW_CMF[n].R_ICB[m])).flatten()[0]
    if idx[m] > 0:
        if m < len(SW_CMF[n].sw_val) - 1:
            hw_p = (SW_CMF[n].sw_val[m + 1] - SW_CMF[n].sw_val[m]) / 2
        else:
            hw_p = (SW_CMF[n].sw_val[m] - SW_CMF[n].sw_val[m - 1]) / 2
        if m > 0:
            hw_m = (SW_CMF[n].sw_val[m] - SW_CMF[n].sw_val[m - 1]) / 2
        else:
            hw_m = (SW_CMF[n].sw_val[m + 1] - SW_CMF[n].sw_val[m]) / 2

        ax[i, j].plot(
            np.array([s2y(SW_CMF[n].t[i_time])[idx[m]] / 1e9] * 2),
            np.array([SW_CMF[n].sw_val[m]] * 2) + [-hw_m, +hw_p],
            ":.",
            color="red",
            linewidth=2,
        )

cb = fig.colorbar(
    p,
    ax=ax[i, j],
    location="right",
)
cb.ax.set_title("$L_c$ (km)", loc="left", fontsize=10, pad=8)

ax[i, j].set_xlabel("$t$ (Gyr)")
ax[i, j].set_ylabel("CMF")
ax[i, j].set_yticks(SW_CMF[n].sw_val)
ax[i, j].set_yticklabels(SW_CMF[n].sw_val)

handles = [
    mpl.patches.Rectangle(
        (0, 0),
        1,
        1,
        edgecolor="lime",
        facecolor="none",
    ),
    mpl.patches.Patch(
        facecolor="none",
        edgecolor="lime",
        hatch="///",
    ),
    mpl.lines.Line2D([0], [0], linestyle=":", color="red"),
]
labels = ["$Q_{CMB} < Q_{A,c}$", "$q_c \geq 0$", "ICN"]
ax[i, j].legend(handles, labels, loc="lower right", fontsize="small")

subplots_label(ax)
if save_fig:
    fig.savefig(save_path + "/main_evolution_M_CMF.pdf")

# %% Main: Dynamo operation (M + CMF)
# =============================================================================
fig, ax = plt.subplots(2, 2, figsize=(8, 6), sharex=True)

n, j = 1, 0

i_time = np.argwhere(~np.isnan(SW_M[n].t)[:, 0]).flatten()[0]
t_m, sw_val_m = np.meshgrid(SW_M[n].t[i_time], SW_M[n].sw_val)

mask_BMO = np.zeros((len(SW_M[n].sw_val), len(SW_M[n].t[i_time])))
for i in range(len(SW_M[n].sw_val)):
    mask_BMO[i] = np.where(SW_M[n].t[i] < t_BMO_M[n][i], 1, np.nan)

i = 0
p = ax[i, j].pcolormesh(
    s2y(SW_M[n].t[i_time]) / 1e9,
    SW_M[n].sw_val,
    SW_M[n].Rm_S_BMO_S2020 * mask_BMO,
    cmap="magma_r",
    shading="auto",
    vmin=0,
    rasterized=True,
)

idx = np.zeros(len(SW_M[n].sw_val), dtype=object)
for m in range(len(SW_M[n].sw_val)):
    idx[m] = np.argwhere(
        np.abs(
            np.diff(
                np.sign(
                    SW_M[n].Rm_S_BMO_S2020[m] * mask_BMO[m]
                    - SW_M[n].param[m].Rm_crit_BMO
                )
            )
        )
        > 0
    ).flatten()
    for l in range(len(idx[m])):
        if m < len(SW_M[n].sw_val) - 1:
            hw_p = (SW_M[n].sw_val[m + 1] - SW_M[n].sw_val[m]) / 2
        else:
            hw_p = (SW_M[n].sw_val[m] - SW_M[n].sw_val[m - 1]) / 2
        if m > 0:
            hw_m = (SW_M[n].sw_val[m] - SW_M[n].sw_val[m - 1]) / 2
        else:
            hw_m = (SW_M[n].sw_val[m + 1] - SW_M[n].sw_val[m]) / 2

        x = np.array([s2y(SW_M[n].t[i_time])[idx[m][l]] / 1e9] * 2)
        y = np.array([SW_M[n].sw_val[m]] * 2) + [-hw_m, +hw_p]
        ax[i, j].plot(
            x,
            y,
            ".-",
            color="blue",
            linewidth=2,
        )

cb = fig.colorbar(
    p,
    ax=ax[i, j],
    location="right",
)
cb.ax.set_title("$R_{m_b}$", loc="left", fontsize=10, pad=8)

ax[i, j].set_ylabel("$M_P/M_{\\oplus}$")
ax[i, j].set_title("$\\mathrm{CMF}= $" + "${:.2f}$".format(CMF_M[n]))
ax[i, j].set_yticks(SW_M[n].sw_val)
ax[i, j].set_yticklabels(SW_M[n].sw_val.astype(int))

handles = [
    mpl.lines.Line2D(
        [0],
        [0],
        color="blue",
    ),
]
labels = [
    "$R_{m_b} = 40$",
]
ax[i, j].legend(handles, labels, loc="lower right", fontsize="small")

mask_OC = np.where(SW_M[n].L_OC > 0, 1, np.nan)

i = 1
p = ax[i, j].pcolormesh(
    s2y(SW_M[n].t[i_time]) / 1e9,
    SW_M[n].sw_val,
    SW_M[n].E_PHI_core_S2020 / 1e6 * mask_OC,
    cmap="RdBu",
    shading="auto",
    norm=mpl.colors.SymLogNorm(
        linthresh=200,
        vmin=-np.max(np.abs(SW_M[n].E_PHI_core_S2020 / 1e6)),
        vmax=+np.max(np.abs(SW_M[n].E_PHI_core_S2020 / 1e6)),
    ),
    rasterized=True,
)

idx = np.zeros(len(SW_M[n].sw_val), dtype=object)
for m in range(len(SW_M[n].sw_val)):
    idx[m] = np.argwhere(
        np.abs(np.diff(np.sign(SW_M[n].E_PHI_core_S2020[m] * mask_OC[m]))) > 0
    ).flatten()
    for l in range(len(idx[m])):
        if m < len(SW_M[n].sw_val) - 1:
            hw_p = (SW_M[n].sw_val[m + 1] - SW_M[n].sw_val[m]) / 2
        else:
            hw_p = (SW_M[n].sw_val[m] - SW_M[n].sw_val[m - 1]) / 2
        if m > 0:
            hw_m = (SW_M[n].sw_val[m] - SW_M[n].sw_val[m - 1]) / 2
        else:
            hw_m = (SW_M[n].sw_val[m + 1] - SW_M[n].sw_val[m]) / 2

        ax[i, j].plot(
            np.array([s2y(SW_M[n].t[i_time])[idx[m][l]] / 1e9] * 2),
            np.array([SW_M[n].sw_val[m]] * 2) + [-hw_m, +hw_p],
            ".-",
            color="blue",
            linewidth=2,
            zorder=15,
        )

idx = np.zeros(len(SW_M[n].sw_val), dtype=object)
for m in range(len(SW_M[n].sw_val)):
    idx[m] = np.argwhere(~np.isnan(SW_M[n].R_ICB[m])).flatten()[0]
    if idx[m] > 0:
        if m < len(SW_M[n].sw_val) - 1:
            hw_p = (SW_M[n].sw_val[m + 1] - SW_M[n].sw_val[m]) / 2
        else:
            hw_p = (SW_M[n].sw_val[m] - SW_M[n].sw_val[m - 1]) / 2
        if m > 0:
            hw_m = (SW_M[n].sw_val[m] - SW_M[n].sw_val[m - 1]) / 2
        else:
            hw_m = (SW_M[n].sw_val[m + 1] - SW_M[n].sw_val[m]) / 2

        ax[i, j].plot(
            np.array([s2y(SW_M[n].t[i_time])[idx[m]] / 1e9] * 2),
            np.array([SW_M[n].sw_val[m]] * 2) + [-hw_m, +hw_p],
            ":.",
            color="red",
            linewidth=2,
            zorder=20,
        )

cb = fig.colorbar(
    p,
    ax=ax[i, j],
    location="right",
)
cb.ax.set_title(
    "$E_{\\Phi,c}$ ($\\mathrm{MW.K^{-1}}$)", loc="left", fontsize=10, pad=8, x=-3
)

ax[i, j].set_xlabel("$t$ (Gyr)")
ax[i, j].set_ylabel("$M_P/M_{\\oplus}$")
ax[i, j].set_yticks(SW_M[n].sw_val)
ax[i, j].set_yticklabels(SW_M[n].sw_val.astype(int))

handles = [
    mpl.lines.Line2D(
        [0],
        [0],
        color="blue",
    ),
    mpl.lines.Line2D(
        [0],
        [0],
        linestyle=":",
        color="red",
    ),
]
labels = [
    "$E_{\\Phi,c} = 0$",
    "ICN",
]
ax[i, j].legend(handles, labels, loc="center right", fontsize="small")

n, j = 3, 1

i_time = np.argwhere(~np.isnan(SW_CMF[n].t)[:, 0]).flatten()[0]
t_m, sw_val_m = np.meshgrid(SW_CMF[n].t[i_time], SW_CMF[n].sw_val)

mask_BMO = np.zeros((len(SW_CMF[n].sw_val), len(SW_CMF[n].t[i_time])))
for i in range(len(SW_CMF[n].sw_val)):
    mask_BMO[i] = np.where(SW_CMF[n].t[i] < t_BMO_CMF[n][i], 1, np.nan)

i = 0
p = ax[i, j].pcolormesh(
    s2y(SW_CMF[n].t[i_time]) / 1e9,
    SW_CMF[n].sw_val,
    SW_CMF[n].Rm_S_BMO_S2020 * mask_BMO,
    cmap="magma_r",
    shading="auto",
    vmin=0,
    rasterized=True,
)

idx = np.zeros(len(SW_CMF[n].sw_val), dtype=object)
for m in range(len(SW_CMF[n].sw_val)):
    idx[m] = np.argwhere(
        np.abs(
            np.diff(
                np.sign(
                    SW_CMF[n].Rm_S_BMO_S2020[m] * mask_BMO[m]
                    - SW_CMF[n].param[m].Rm_crit_BMO
                )
            )
        )
        > 0
    ).flatten()
    for l in range(len(idx[m])):
        if m < len(SW_CMF[n].sw_val) - 1:
            hw_p = (SW_CMF[n].sw_val[m + 1] - SW_CMF[n].sw_val[m]) / 2
        else:
            hw_p = (SW_CMF[n].sw_val[m] - SW_CMF[n].sw_val[m - 1]) / 2
        if m > 0:
            hw_m = (SW_CMF[n].sw_val[m] - SW_CMF[n].sw_val[m - 1]) / 2
        else:
            hw_m = (SW_CMF[n].sw_val[m + 1] - SW_CMF[n].sw_val[m]) / 2

        x = np.array([s2y(SW_CMF[n].t[i_time])[idx[m][l]] / 1e9] * 2)
        y = np.array([SW_CMF[n].sw_val[m]] * 2) + [-hw_m, +hw_p]
        ax[i, j].plot(
            x,
            y,
            ".-",
            color="blue",
            linewidth=2,
        )

cb = fig.colorbar(
    p,
    ax=ax[i, j],
    location="right",
)
cb.ax.set_title("$R_{m_b}$", loc="left", fontsize=10, pad=8)

ax[i, j].set_ylabel("CMF")
ax[i, j].set_title("$M_P={:.0f}$ ".format(M_CMF[n]) + "$M_{\\oplus}$")
ax[i, j].set_yticks(SW_CMF[n].sw_val)
ax[i, j].set_yticklabels(SW_CMF[n].sw_val)

handles = [
    mpl.lines.Line2D(
        [0],
        [0],
        color="blue",
    ),
]
labels = [
    "$R_{m_b} = 40$",
]
ax[i, j].legend(handles, labels, loc="lower right", fontsize="small")

mask_OC = np.where(SW_CMF[n].L_OC > 0, 1, np.nan)

i = 1
p = ax[i, j].pcolormesh(
    s2y(SW_CMF[n].t[i_time]) / 1e9,
    SW_CMF[n].sw_val,
    SW_CMF[n].E_PHI_core_S2020 / 1e6 * mask_OC,
    cmap="RdBu",
    shading="auto",
    norm=mpl.colors.SymLogNorm(
        linthresh=200,
        vmin=-np.max(np.abs(SW_CMF[n].E_PHI_core_S2020 / 1e6)),
        vmax=+np.max(np.abs(SW_CMF[n].E_PHI_core_S2020 / 1e6)),
    ),
    rasterized=True,
)

idx = np.zeros(len(SW_CMF[n].sw_val), dtype=object)
for m in range(len(SW_CMF[n].sw_val)):
    idx[m] = np.argwhere(
        np.abs(np.diff(np.sign(SW_CMF[n].E_PHI_core_S2020[m] * mask_OC[m]))) > 0
    ).flatten()
    for l in range(len(idx[m])):
        if m < len(SW_CMF[n].sw_val) - 1:
            hw_p = (SW_CMF[n].sw_val[m + 1] - SW_CMF[n].sw_val[m]) / 2
        else:
            hw_p = (SW_CMF[n].sw_val[m] - SW_CMF[n].sw_val[m - 1]) / 2
        if m > 0:
            hw_m = (SW_CMF[n].sw_val[m] - SW_CMF[n].sw_val[m - 1]) / 2
        else:
            hw_m = (SW_CMF[n].sw_val[m + 1] - SW_CMF[n].sw_val[m]) / 2

        ax[i, j].plot(
            np.array([s2y(SW_CMF[n].t[i_time])[idx[m][l]] / 1e9] * 2),
            np.array([SW_CMF[n].sw_val[m]] * 2) + [-hw_m, +hw_p],
            ".-",
            color="blue",
            linewidth=2,
            zorder=15,
        )

idx = np.zeros(len(SW_CMF[n].sw_val), dtype=object)
for m in range(len(SW_CMF[n].sw_val)):
    idx[m] = np.argwhere(~np.isnan(SW_CMF[n].R_ICB[m])).flatten()[0]
    if idx[m] > 0:
        if m < len(SW_CMF[n].sw_val) - 1:
            hw_p = (SW_CMF[n].sw_val[m + 1] - SW_CMF[n].sw_val[m]) / 2
        else:
            hw_p = (SW_CMF[n].sw_val[m] - SW_CMF[n].sw_val[m - 1]) / 2
        if m > 0:
            hw_m = (SW_CMF[n].sw_val[m] - SW_CMF[n].sw_val[m - 1]) / 2
        else:
            hw_m = (SW_CMF[n].sw_val[m + 1] - SW_CMF[n].sw_val[m]) / 2

        ax[i, j].plot(
            np.array([s2y(SW_CMF[n].t[i_time])[idx[m]] / 1e9] * 2),
            np.array([SW_CMF[n].sw_val[m]] * 2) + [-hw_m, +hw_p],
            ":.",
            color="red",
            linewidth=2,
            zorder=20,
        )

cb = fig.colorbar(
    p,
    ax=ax[i, j],
    location="right",
)
cb.ax.set_title(
    "$E_{\\Phi,c}$ ($\\mathrm{MW.K^{-1}}$)", loc="left", fontsize=10, pad=8, x=-3
)

ax[i, j].set_xlabel("$t$ (Gyr)")
ax[i, j].set_ylabel("CMF")
ax[i, j].set_yticks(SW_CMF[n].sw_val)
ax[i, j].set_yticklabels(SW_CMF[n].sw_val)

handles = [
    mpl.lines.Line2D(
        [0],
        [0],
        color="blue",
    ),
    mpl.lines.Line2D(
        [0],
        [0],
        linestyle=":",
        color="red",
    ),
]
labels = [
    "$E_{\\Phi,c} = 0$",
    "ICN",
]
ax[i, j].legend(handles, labels, loc="lower right", fontsize="small")

subplots_label(ax)
if save_fig:
    fig.savefig(save_path + "/main_dynamo_M_CMF.pdf")

# %% Main: Magnetic field intensity (M + CMF)
# =============================================================================
fig, ax = plt.subplots(3, 2, figsize=(8, 9), sharex=True)

n, j = 1, 0

i_time = np.argwhere(~np.isnan(SW_M[n].t)[:, 0]).flatten()[0]
t_m, sw_val_m = np.meshgrid(SW_M[n].t[i_time], SW_M[n].sw_val)

mask_BMO = np.zeros((len(SW_M[n].sw_val), len(SW_M[n].t[i_time])))
for i in range(len(SW_M[n].sw_val)):
    mask_BMO[i] = np.where(
        (SW_M[n].Rm_S_BMO_S2020[i] > SW_M[n].param[i].Rm_crit_BMO) & mask_BMO_M[n][i],
        1,
        np.nan,
    )

i = 0
p = ax[i, j].pcolormesh(
    s2y(SW_M[n].t[i_time]) / 1e9,
    SW_M[n].sw_val,
    SW_M[n].BS_S_BMO_cst_S2020 * 1e6 * mask_BMO,
    cmap="cividis",
    shading="auto",
    vmin=0,
    rasterized=True,
)

cb = fig.colorbar(
    p,
    ax=ax[i, j],
    location="right",
)
cb.ax.set_title("$B_{P,b}$ ($\\mathrm{\\mu T}$)", loc="left", fontsize=10, pad=8, x=-1)

ax[i, j].set_ylabel("$M_P/M_{\\oplus}$")
ax[i, j].set_title("$\\mathrm{CMF}= $" + "${:.2f}$".format(CMF_M[n]))
ax[i, j].set_yticks(SW_M[n].sw_val)
ax[i, j].set_yticklabels(SW_M[n].sw_val.astype(int))

mask_OC = np.where(SW_M[n].Rm_S_core_S2020 > 40, 1, np.nan)

i = 1
p = ax[i, j].pcolormesh(
    s2y(SW_M[n].t[i_time]) / 1e9,
    SW_M[n].sw_val,
    SW_M[n].BS_S_core_cst_S2020 * 1e6 * mask_OC,
    cmap="cividis",
    shading="auto",
    vmin=0,
    rasterized=True,
)

idx = np.zeros(len(SW_M[n].sw_val), dtype=object)
for m in range(len(SW_M[n].sw_val)):
    idx[m] = np.argwhere(~np.isnan(SW_M[n].R_ICB[m])).flatten()[0]
    if idx[m] > 0:
        if m < len(SW_M[n].sw_val) - 1:
            hw_p = (SW_M[n].sw_val[m + 1] - SW_M[n].sw_val[m]) / 2
        else:
            hw_p = (SW_M[n].sw_val[m] - SW_M[n].sw_val[m - 1]) / 2
        if m > 0:
            hw_m = (SW_M[n].sw_val[m] - SW_M[n].sw_val[m - 1]) / 2
        else:
            hw_m = (SW_M[n].sw_val[m + 1] - SW_M[n].sw_val[m]) / 2

        ax[i, j].plot(
            np.array([s2y(SW_M[n].t[i_time])[idx[m]] / 1e9] * 2),
            np.array([SW_M[n].sw_val[m]] * 2) + [-hw_m, +hw_p],
            ":.",
            color="red",
            linewidth=2,
        )

cb = fig.colorbar(
    p,
    ax=ax[i, j],
    location="right",
)
cb.ax.set_title("$B_{P,c}$ ($\\mathrm{\\mu T}$)", loc="left", fontsize=10, pad=8, x=-1)

ax[i, j].set_ylabel("$M_P/M_{\\oplus}$")
ax[i, j].set_yticks(SW_M[n].sw_val)
ax[i, j].set_yticklabels(SW_M[n].sw_val.astype(int))

handles = [mpl.lines.Line2D([0], [0], linestyle=":", color="red")]
labels = ["ICN"]
ax[i, j].legend(handles, labels, loc="center right", fontsize="small")

i = 2
field = (SW_M[n].BS_S_BMO_cst_S2020 * mask_BMO) / (
    SW_M[n].BS_S_core_cst_S2020 * mask_OC
)
p = ax[i, j].pcolormesh(
    s2y(SW_M[n].t[i_time]) / 1e9,
    SW_M[n].sw_val,
    field,
    cmap="plasma_r",
    shading="auto",
    norm=mpl.colors.LogNorm(),
    rasterized=True,
)

idx_beg_BMO = np.zeros(len(SW_M[n].sw_val), dtype=object)
idx_end_BMO = np.zeros(len(SW_M[n].sw_val), dtype=object)
for m in range(len(SW_M[n].sw_val)):
    idx_beg_BMO[m] = np.argwhere(
        ~np.isnan(SW_M[n].BS_S_BMO_cst_S2020[m] * mask_BMO[m])
    ).flatten()[0]

    idx_end_BMO[m] = np.argwhere(
        ~np.isnan(SW_M[n].BS_S_BMO_cst_S2020[m] * mask_BMO[m])
    ).flatten()[-1]

idx_beg_core = np.zeros(len(SW_M[n].sw_val), dtype=object)
idx_end_core = np.zeros(len(SW_M[n].sw_val), dtype=object)
for m in range(len(SW_M[n].sw_val)):
    idx_beg_core[m] = np.argwhere(
        ~np.isnan(SW_M[n].BS_S_core_cst_S2020[m] * mask_OC[m])
    ).flatten()[0]

    idx_end_core[m] = np.argwhere(
        ~np.isnan(SW_M[n].BS_S_core_cst_S2020[m] * mask_OC[m])
    ).flatten()[-1]

for m in range(len(SW_M[n].sw_val)):
    if m < len(SW_M[n].sw_val) - 1:
        hw_p = (SW_M[n].sw_val[m + 1] - SW_M[n].sw_val[m]) / 2
    else:
        hw_p = (SW_M[n].sw_val[m] - SW_M[n].sw_val[m - 1]) / 2
    if m > 0:
        hw_m = (SW_M[n].sw_val[m] - SW_M[n].sw_val[m - 1]) / 2
    else:
        hw_m = (SW_M[n].sw_val[m + 1] - SW_M[n].sw_val[m]) / 2

    if idx_beg_BMO[m] < idx_beg_core[m]:
        rec = mpl.patches.Rectangle(
            (
                s2y(SW_M[n].t[i_time])[idx_beg_BMO[m]] / 1e9,
                SW_M[n].sw_val[m] - hw_m,
            ),
            (
                s2y(SW_M[n].t[i_time])[
                    np.nanmin(
                        [
                            idx_end_BMO[m],
                            idx_beg_core[m],
                        ]
                    )
                ]
                - s2y(SW_M[n].t[i_time])[idx_beg_BMO[m]]
            )
            / 1e9,
            hw_m + hw_p,
            edgecolor=tab20c(5),
            facecolor="none",
            linewidth=1.5,
            zorder=10,
        )
    elif idx_beg_BMO[m] > idx_beg_core[m]:
        rec = mpl.patches.Rectangle(
            (
                s2y(SW_M[n].t[i_time])[idx_beg_core[m]] / 1e9,
                SW_M[n].sw_val[m] - hw_m,
            ),
            (
                s2y(SW_M[n].t[i_time])[
                    np.nanmin(
                        [
                            idx_beg_BMO[m],
                            idx_end_core[m],
                        ]
                    )
                ]
                - s2y(SW_M[n].t[i_time])[idx_beg_core[m]]
            )
            / 1e9,
            hw_m + hw_p,
            edgecolor=tab20c(16),
            facecolor="none",
            linewidth=1.5,
            zorder=10,
        )

    ax[i, j].add_patch(rec)

    if idx_end_BMO[m] < idx_end_core[m]:
        rec = mpl.patches.Rectangle(
            (
                s2y(SW_M[n].t[i_time])[
                    np.nanmax(
                        [
                            idx_end_BMO[m],
                            idx_beg_core[m],
                        ]
                    )
                ]
                / 1e9,
                SW_M[n].sw_val[m] - hw_m,
            ),
            (
                s2y(SW_M[n].t[i_time])[idx_end_core[m]]
                - s2y(SW_M[n].t[i_time])[
                    np.nanmax(
                        [
                            idx_end_BMO[m],
                            idx_beg_core[m],
                        ]
                    )
                ]
            )
            / 1e9,
            hw_m + hw_p,
            edgecolor=tab20c(16),
            facecolor="none",
            linewidth=1.5,
            zorder=10,
        )
    elif idx_end_BMO[m] > idx_end_core[m]:
        rec = mpl.patches.Rectangle(
            (
                s2y(SW_M[n].t[i_time])[
                    np.nanmax(
                        [
                            idx_beg_BMO[m],
                            idx_end_core[m],
                        ]
                    )
                ]
                / 1e9,
                SW_M[n].sw_val[m] - hw_m,
            ),
            (
                s2y(SW_M[n].t[i_time])[idx_end_BMO[m]]
                - s2y(SW_M[n].t[i_time])[
                    np.nanmax(
                        [
                            idx_beg_BMO[m],
                            idx_end_core[m],
                        ]
                    )
                ]
            )
            / 1e9,
            hw_m + hw_p,
            edgecolor=tab20c(5),
            facecolor="none",
            linewidth=1.5,
            zorder=10,
        )

    ax[i, j].add_patch(rec)

cb = fig.colorbar(
    p,
    ax=ax[i, j],
    location="right",
)
cb.ax.set_title("$B_{P,b}/B_{P,c}$", loc="left", fontsize=10, pad=8, x=-1)

ax[i, j].set_xlabel("$t$ (Gyr)")
ax[i, j].set_ylabel("$M_P/M_{\\oplus}$")
ax[i, j].set_yticks(SW_M[n].sw_val)
ax[i, j].set_yticklabels(SW_M[n].sw_val.astype(int))

handles = [
    mpl.patches.Rectangle(
        (0, 0),
        1,
        1,
        edgecolor=tab20c(5),
        facecolor="none",
    ),
    mpl.patches.Rectangle(
        (0, 0),
        1,
        1,
        edgecolor=tab20c(16),
        facecolor="none",
    ),
]
labels = ["BMO only", "Core only"]
ax[i, j].legend(handles, labels, loc="center right", fontsize="small")

n, j = 3, 1

i_time = np.argwhere(~np.isnan(SW_CMF[n].t)[:, 0]).flatten()[0]
t_m, sw_val_m = np.meshgrid(SW_CMF[n].t[i_time], SW_CMF[n].sw_val)

mask_BMO = np.zeros((len(SW_CMF[n].sw_val), len(SW_CMF[n].t[i_time])))
for i in range(len(SW_CMF[n].sw_val)):
    mask_BMO[i] = np.where(
        (SW_CMF[n].Rm_S_BMO_S2020[i] > SW_CMF[n].param[i].Rm_crit_BMO)
        & mask_BMO_CMF[n][i],
        1,
        np.nan,
    )

i = 0
p = ax[i, j].pcolormesh(
    s2y(SW_CMF[n].t[i_time]) / 1e9,
    SW_CMF[n].sw_val,
    SW_CMF[n].BS_S_BMO_cst_S2020 * 1e6 * mask_BMO,
    cmap="cividis",
    shading="auto",
    vmin=0,
    rasterized=True,
)

cb = fig.colorbar(
    p,
    ax=ax[i, j],
    location="right",
)
cb.ax.set_title("$B_{P,b}$ ($\\mathrm{\\mu T}$)", loc="left", fontsize=10, pad=8, x=-1)

ax[i, j].set_ylabel("CMF")
ax[i, j].set_title("$M_P={:.0f}$ ".format(M_CMF[n]) + "$M_{\\oplus}$")
ax[i, j].set_yticks(SW_CMF[n].sw_val)
ax[i, j].set_yticklabels(SW_CMF[n].sw_val.astype(float))

mask_OC = np.where(SW_CMF[n].Rm_S_core_S2020 > 40, 1, np.nan)

i = 1
p = ax[i, j].pcolormesh(
    s2y(SW_CMF[n].t[i_time]) / 1e9,
    SW_CMF[n].sw_val,
    SW_CMF[n].BS_S_core_cst_S2020 * 1e6 * mask_OC,
    cmap="cividis",
    shading="auto",
    vmin=0,
    rasterized=True,
)

idx = np.zeros(len(SW_CMF[n].sw_val), dtype=object)
for m in range(len(SW_CMF[n].sw_val)):
    idx[m] = np.argwhere(~np.isnan(SW_CMF[n].R_ICB[m])).flatten()[0]
    if idx[m] > 0:
        if m < len(SW_CMF[n].sw_val) - 1:
            hw_p = (SW_CMF[n].sw_val[m + 1] - SW_CMF[n].sw_val[m]) / 2
        else:
            hw_p = (SW_CMF[n].sw_val[m] - SW_CMF[n].sw_val[m - 1]) / 2
        if m > 0:
            hw_m = (SW_CMF[n].sw_val[m] - SW_CMF[n].sw_val[m - 1]) / 2
        else:
            hw_m = (SW_CMF[n].sw_val[m + 1] - SW_CMF[n].sw_val[m]) / 2

        ax[i, j].plot(
            np.array([s2y(SW_CMF[n].t[i_time])[idx[m]] / 1e9] * 2),
            np.array([SW_CMF[n].sw_val[m]] * 2) + [-hw_m, +hw_p],
            ":.",
            color="red",
            linewidth=2,
            zorder=20,
        )

cb = fig.colorbar(
    p,
    ax=ax[i, j],
    location="right",
)
cb.ax.set_title("$B_{P,c}$ ($\\mathrm{\\mu T}$)", loc="left", fontsize=10, pad=8, x=-1)

ax[i, j].set_ylabel("CMF")
ax[i, j].set_yticks(SW_CMF[n].sw_val)
ax[i, j].set_yticklabels(SW_CMF[n].sw_val.astype(float))

handles = [mpl.lines.Line2D([0], [0], linestyle=":", color="red")]
labels = ["ICN"]
ax[i, j].legend(handles, labels, loc="lower right", fontsize="small")

i = 2
field = (SW_CMF[n].BS_S_BMO_cst_S2020 * mask_BMO) / (
    SW_CMF[n].BS_S_core_cst_S2020 * mask_OC
)
p = ax[i, j].pcolormesh(
    s2y(SW_CMF[n].t[i_time]) / 1e9,
    SW_CMF[n].sw_val,
    field,
    cmap="plasma_r",
    shading="auto",
    norm=mpl.colors.LogNorm(),
    rasterized=True,
)

idx_beg_BMO = np.zeros(len(SW_CMF[n].sw_val), dtype=object)
idx_end_BMO = np.zeros(len(SW_CMF[n].sw_val), dtype=object)
for m in range(len(SW_CMF[n].sw_val)):
    if np.all(np.isnan(mask_BMO[m])):
        idx_beg_BMO[m] = np.nan
        idx_end_BMO[m] = np.nan
    else:
        idx_beg_BMO[m] = np.argwhere(
            ~np.isnan(SW_CMF[n].BS_S_BMO_cst_S2020[m] * mask_BMO[m])
        ).flatten()[0]

        idx_end_BMO[m] = np.argwhere(
            ~np.isnan(SW_CMF[n].BS_S_BMO_cst_S2020[m] * mask_BMO[m])
        ).flatten()[-1]

idx_beg_core = np.zeros(len(SW_CMF[n].sw_val), dtype=object)
idx_end_core = np.zeros(len(SW_CMF[n].sw_val), dtype=object)
for m in range(len(SW_CMF[n].sw_val)):
    if np.all(np.isnan(mask_OC[m])):
        idx_beg_core[m] = np.nan
        idx_end_core[m] = np.nan
    else:
        idx_beg_core[m] = np.argwhere(
            ~np.isnan(SW_CMF[n].BS_S_core_cst_S2020[m] * mask_OC[m])
        ).flatten()[0]

        idx_end_core[m] = np.argwhere(
            ~np.isnan(SW_CMF[n].BS_S_core_cst_S2020[m] * mask_OC[m])
        ).flatten()[-1]

for m in range(len(SW_CMF[n].sw_val)):
    if m < len(SW_CMF[n].sw_val) - 1:
        hw_p = (SW_CMF[n].sw_val[m + 1] - SW_CMF[n].sw_val[m]) / 2
    else:
        hw_p = (SW_CMF[n].sw_val[m] - SW_CMF[n].sw_val[m - 1]) / 2
    if m > 0:
        hw_m = (SW_CMF[n].sw_val[m] - SW_CMF[n].sw_val[m - 1]) / 2
    else:
        hw_m = (SW_CMF[n].sw_val[m + 1] - SW_CMF[n].sw_val[m]) / 2

    if idx_beg_BMO[m] < idx_beg_core[m]:
        rec = mpl.patches.Rectangle(
            (
                s2y(SW_CMF[n].t[i_time])[idx_beg_BMO[m]] / 1e9,
                SW_CMF[n].sw_val[m] - hw_m,
            ),
            (
                s2y(SW_CMF[n].t[i_time])[
                    np.nanmin(
                        [
                            idx_end_BMO[m],
                            idx_beg_core[m],
                        ]
                    )
                ]
                - s2y(SW_CMF[n].t[i_time])[idx_beg_BMO[m]]
            )
            / 1e9,
            hw_m + hw_p,
            edgecolor=tab20c(5),
            facecolor="none",
            linewidth=1.5,
            zorder=10,
        )
    elif idx_beg_BMO[m] > idx_beg_core[m]:
        rec = mpl.patches.Rectangle(
            (
                s2y(SW_CMF[n].t[i_time])[idx_beg_core[m]] / 1e9,
                SW_CMF[n].sw_val[m] - hw_m,
            ),
            (
                s2y(SW_CMF[n].t[i_time])[
                    np.nanmin(
                        [
                            idx_beg_BMO[m],
                            idx_end_core[m],
                        ]
                    )
                ]
                - s2y(SW_CMF[n].t[i_time])[idx_beg_core[m]]
            )
            / 1e9,
            hw_m + hw_p,
            edgecolor=tab20c(16),
            facecolor="none",
            linewidth=1.5,
            zorder=10,
        )

    ax[i, j].add_patch(rec)

    if idx_end_BMO[m] < idx_end_core[m]:
        rec = mpl.patches.Rectangle(
            (
                s2y(SW_CMF[n].t[i_time])[
                    np.nanmax(
                        [
                            idx_end_BMO[m],
                            idx_beg_core[m],
                        ]
                    )
                ]
                / 1e9,
                SW_CMF[n].sw_val[m] - hw_m,
            ),
            (
                s2y(SW_CMF[n].t[i_time])[idx_end_core[m]]
                - s2y(SW_CMF[n].t[i_time])[
                    np.nanmax(
                        [
                            idx_end_BMO[m],
                            idx_beg_core[m],
                        ]
                    )
                ]
            )
            / 1e9,
            hw_m + hw_p,
            edgecolor=tab20c(16),
            facecolor="none",
            linewidth=1.5,
            zorder=10,
        )
    elif idx_end_BMO[m] > idx_end_core[m]:
        rec = mpl.patches.Rectangle(
            (
                s2y(SW_CMF[n].t[i_time])[
                    np.nanmax(
                        [
                            idx_beg_BMO[m],
                            idx_end_core[m],
                        ]
                    )
                ]
                / 1e9,
                SW_CMF[n].sw_val[m] - hw_m,
            ),
            (
                s2y(SW_CMF[n].t[i_time])[idx_end_BMO[m]]
                - s2y(SW_CMF[n].t[i_time])[
                    np.nanmax(
                        [
                            idx_beg_BMO[m],
                            idx_end_core[m],
                        ]
                    )
                ]
            )
            / 1e9,
            hw_m + hw_p,
            edgecolor=tab20c(5),
            facecolor="none",
            linewidth=1.5,
            zorder=10,
        )

    ax[i, j].add_patch(rec)

    if np.isnan(idx_beg_BMO[m]) and np.isnan(idx_end_BMO[m]):
        rec = mpl.patches.Rectangle(
            (
                s2y(SW_CMF[n].t[i_time])[idx_beg_core[m]] / 1e9,
                SW_CMF[n].sw_val[m] - hw_m,
            ),
            (
                s2y(SW_CMF[n].t[i_time])[idx_end_core[m]]
                - s2y(SW_CMF[n].t[i_time])[idx_beg_core[m]]
            )
            / 1e9,
            hw_m + hw_p,
            edgecolor=tab20c(16),
            facecolor="none",
            linewidth=1.5,
            zorder=10,
        )
        ax[i, j].add_patch(rec)

    if np.isnan(idx_beg_core[m]) and np.isnan(idx_end_core[m]):
        rec = mpl.patches.Rectangle(
            (
                s2y(SW_CMF[n].t[i_time])[idx_beg_BMO[m]] / 1e9,
                SW_CMF[n].sw_val[m] - hw_m,
            ),
            (
                s2y(SW_CMF[n].t[i_time])[idx_end_BMO[m]]
                - s2y(SW_CMF[n].t[i_time])[idx_beg_BMO[m]]
            )
            / 1e9,
            hw_m + hw_p,
            edgecolor=tab20c(5),
            facecolor="none",
            linewidth=1.5,
            zorder=10,
        )
        ax[i, j].add_patch(rec)

cb = fig.colorbar(
    p,
    ax=ax[i, j],
    location="right",
)
cb.ax.set_title("$B_{P,b}/B_{P,c}$", loc="left", fontsize=10, pad=8, x=-1)

ax[i, j].set_xlabel("$t$ (Gyr)")
ax[i, j].set_ylabel("CMF")
ax[i, j].set_yticks(SW_CMF[n].sw_val)
ax[i, j].set_yticklabels(SW_CMF[n].sw_val.astype(float))

handles = [
    mpl.patches.Rectangle(
        (0, 0),
        1,
        1,
        edgecolor=tab20c(5),
        facecolor="none",
    ),
    mpl.patches.Rectangle(
        (0, 0),
        1,
        1,
        edgecolor=tab20c(16),
        facecolor="none",
    ),
]
labels = ["BMO only", "Core only"]
ax[i, j].legend(handles, labels, loc="lower right", fontsize="small")

subplots_label(ax)
if save_fig:
    fig.savefig(save_path + "/main_magnetic_M_CMF.pdf")

# %% Main: Conductivity constraints
# =============================================================================
# Processing
M_p, CMF_p = (
    M_CMF,
    np.unique(np.array([SW_CMF[n].sw_val for n in range(len(SW_CMF))]).flatten()),
)

sigma_BMO_min, is_DYN_BMO_S2020, is_DYN_BMO_N2025, k_core_min = [
    np.zeros(
        (
            len(M_p),
            len(CMF_p),
        )
    )
    * np.nan
    for _ in range(4)
]

for i in range(len(SW_CMF)):
    for j in range(len(SW_CMF[i].sw_val)):
        c_i = np.argwhere(M_p == M_CMF[i]).flatten()[0]
        c_j = np.argwhere(CMF_p == SW_CMF[i].sw_val[j]).flatten()[0]

        sigma_BMO_min[c_i, c_j] = SW_CMF[i].sigma_BMO_min[j][0]

        is_DYN_BMO_S2020[c_i, c_j] = SW_CMF[i].is_DYN_BMO_S2020[j][0]

        is_DYN_BMO_N2025[c_i, c_j] = SW_CMF[i].is_DYN_BMO_N2025[j][0]

        k_core_min[c_i, c_j] = SW_CMF[i].k_core_min[j][0]

# Figure
fig, ax = plt.subplots(2, 1, figsize=(4, 6), sharex=True)

i = 0
p = ax[i].pcolormesh(
    CMF_p,
    M_p,
    sigma_BMO_min,
    cmap="plasma_r",
    shading="auto",
    norm=mpl.colors.LogNorm(),
    rasterized=True,
)
fig.colorbar(
    p,
    ax=ax[i],
    label="$\\sigma_{b,\\mathrm{min}}$ ($\\mathrm{S.m^{-1}}$)",
    location="right",
)

for ii in range(is_DYN_BMO_N2025.shape[0]):
    for jj in range(is_DYN_BMO_N2025.shape[1]):
        if not is_DYN_BMO_N2025[ii, jj]:
            x_p = p.get_coordinates()[ii, jj, 0]
            y_p = p.get_coordinates()[ii, jj, 1]

            w_p = p.get_coordinates()[ii, jj + 1, 0] - p.get_coordinates()[ii, jj, 0]
            h_p = p.get_coordinates()[ii + 1, jj, 1] - p.get_coordinates()[ii, jj, 1]

            coord = np.array(
                [
                    [x_p, y_p],
                    [x_p + w_p, y_p],
                    [x_p + w_p, y_p + h_p],
                    [x_p, y_p + h_p],
                ]
            )
            poly = mpl.patches.Polygon(
                coord,
                edgecolor="cyan",
                facecolor="none",
                hatch="//",
                linewidth=0,
            )

            ax[i].add_patch(poly)

for ii in range(is_DYN_BMO_S2020.shape[0]):
    for jj in range(is_DYN_BMO_S2020.shape[1]):
        if not is_DYN_BMO_S2020[ii, jj]:
            x_p = p.get_coordinates()[ii, jj, 0]
            y_p = p.get_coordinates()[ii, jj, 1]

            w_p = p.get_coordinates()[ii, jj + 1, 0] - p.get_coordinates()[ii, jj, 0]
            h_p = p.get_coordinates()[ii + 1, jj, 1] - p.get_coordinates()[ii, jj, 1]

            coord = np.array(
                [
                    [x_p, y_p],
                    [x_p + w_p, y_p],
                    [x_p + w_p, y_p + h_p],
                    [x_p, y_p + h_p],
                ]
            )
            poly = mpl.patches.Polygon(
                coord,
                edgecolor="lime",
                facecolor="none",
                hatch="\\\\",
                linewidth=0,
            )

            ax[i].add_patch(poly)

ax[i].set_ylabel("$M_P/M_{\\oplus}$")
ax[i].set_title("BMO")
ax[i].set_xticks(CMF_p)
ax[i].set_xticklabels(CMF_p)
ax[i].set_yticks(M_p)
ax[i].set_yticklabels(M_p.astype(int))
handles = [
    mpl.patches.Patch(
        edgecolor="lime",
        facecolor="none",
        hatch="\\\\\\",
        linewidth=0,
    ),
    mpl.patches.Patch(
        edgecolor="cyan",
        facecolor="none",
        hatch="///",
        linewidth=0,
    ),
]
labels = ["no dynamo (eq. 24)", "no dynamo (eq. 25)"]
ax[i].legend(
    handles,
    labels,
    fontsize="small",
    loc="upper right",
)

i = 1
p = ax[i].pcolormesh(
    CMF_p,
    M_p,
    k_core_min,
    cmap="plasma_r",
    shading="auto",
    rasterized=True,
)
fig.colorbar(
    p,
    ax=ax[i],
    label="$k_{c,\\mathrm{max}}$ ($\\mathrm{W.m^{-1}.K^{-1}}$)",
    location="right",
)

k_avg = []
for ii in range(is_ICN_0_CMF.shape[0]):
    for jj in range(is_ICN_0_CMF.shape[1]):
        if ~is_ICN_0_CMF[ii, jj]:
            x_p = p.get_coordinates()[ii, jj, 0]
            y_p = p.get_coordinates()[ii, jj, 1]

            w_p = p.get_coordinates()[ii, jj + 1, 0] - p.get_coordinates()[ii, jj, 0]
            h_p = p.get_coordinates()[ii + 1, jj, 1] - p.get_coordinates()[ii, jj, 1]

            coord = np.array(
                [
                    [x_p, y_p],
                    [x_p + w_p, y_p],
                    [x_p + w_p, y_p + h_p],
                    [x_p, y_p + h_p],
                ]
            )
            poly = mpl.patches.Polygon(
                coord,
                edgecolor="lime",
                facecolor="none",
                hatch="//",
                linewidth=0,
            )

            ax[i].add_patch(poly)

            k_avg = np.append(k_avg, k_core_min[ii, jj])

ax[i].set_xlabel("CMF")
ax[i].set_ylabel("$M_P/M_{\\oplus}$")
ax[i].set_title("Core")
ax[i].set_xticks(CMF_p)
ax[i].set_xticklabels(CMF_p)
ax[i].set_yticks(M_p)
ax[i].set_yticklabels(M_p.astype(int))
handles = [
    mpl.patches.Patch(
        edgecolor="lime",
        facecolor="none",
        hatch="///",
        linewidth=0,
    ),
]
labels = ["ICN at $t>0$"]
ax[i].legend(
    handles,
    labels,
    fontsize="small",
    loc="upper right",
)

subplots_label(ax)

if save_fig:
    fig.savefig(save_path + "/main_conductivity.pdf")

# %% Main: Dynamo summary
# =============================================================================
# Processing
M_p, CMF_p = (
    M_CMF,
    np.unique(np.array([SW_CMF[n].sw_val for n in range(len(SW_CMF))]).flatten()),
)

(BS_S_BMO_core, is_DYN_BMO_S2020, is_DYN_core_S2020) = [
    np.zeros((len(M_p), len(CMF_p))) * np.nan for _ in range(3)
]

(len_DYN_BMO, len_DYN_core, len_DYN_BMO_core) = [
    np.zeros((len(M_p), len(CMF_p))) * np.nan for _ in range(3)
]

(p_DYN_BMO, p_DYN_core, p_DYN_BMO_core) = [
    np.zeros((len(M_p), len(CMF_p))) * np.nan for _ in range(3)
]

for i in range(len(SW_CMF)):
    for j in range(len(SW_CMF[i].sw_val)):
        c_i = np.argwhere(M_p == M_CMF[i]).flatten()[0]
        c_j = np.argwhere(CMF_p == SW_CMF[i].sw_val[j]).flatten()[0]

        # Masks
        mask_BMO = np.where(
            (SW_CMF[i].Rm_S_BMO_S2020[j] > SW_CMF[i].param[j].Rm_crit_BMO)
            & mask_BMO_CMF[i][j],
            1,
            np.nan,
        )

        mask_OC = np.where(
            SW_CMF[i].Rm_S_core_S2020[j] > SW_CMF[i].param[j].Rm_crit_core,
            1,
            np.nan,
        )

        # Surface field
        if np.all(np.isnan(mask_BMO)) or np.all(np.isnan(mask_OC)):
            BS_S_BMO_core[c_i, c_j] = np.nan
        else:
            BS_S_BMO_core[c_i, c_j] = np.nanmean(
                SW_CMF[i].BS_S_BMO_cst_S2020[j] * mask_BMO,
            ) / np.nanmean(SW_CMF[i].BS_S_core_cst_S2020[j] * mask_OC)

        # Dynamo operation
        is_DYN_BMO_S2020[c_i, c_j] = np.any(~np.isnan(mask_BMO))

        is_DYN_core_S2020[c_i, c_j] = np.any(~np.isnan(mask_OC))

        # Dynamo duration
        if np.all(np.isnan(mask_BMO)):
            len_DYN_BMO[c_i, c_j] = np.nan
        else:
            len_DYN_BMO[c_i, c_j] = len(SW_CMF[i].t[j][~np.isnan(mask_BMO)]) / len(
                SW_CMF[i].t[j][~np.isnan(mask_BMO) | ~np.isnan(mask_OC)]
            )

        if np.all(np.isnan(mask_OC)):
            len_DYN_core[c_i, c_j] = np.nan
        else:
            len_DYN_core[c_i, c_j] = len(SW_CMF[i].t[j][~np.isnan(mask_OC)]) / len(
                SW_CMF[i].t[j][~np.isnan(mask_BMO) | ~np.isnan(mask_OC)]
            )

        if np.all(np.isnan(mask_BMO)) or np.all(np.isnan(mask_OC)):
            len_DYN_BMO_core[c_i, c_j] = np.nan
        else:
            len_DYN_BMO_core[c_i, c_j] = len(
                SW_CMF[i].t[j][(~np.isnan(mask_BMO)) & (~np.isnan(mask_OC))]
            ) / len(SW_CMF[i].t[j][(~np.isnan(mask_BMO)) | (~np.isnan(mask_OC))])

        # Dynamo probability
        if np.all(np.isnan(mask_BMO)):
            p_DYN_BMO[c_i, c_j] = np.nan
        else:
            p_DYN_BMO[c_i, c_j] = len(SW_CMF[i].t[j][~np.isnan(mask_BMO)]) / len(
                SW_CMF[i].t[j]
            )

        if np.all(np.isnan(mask_OC)):
            p_DYN_core[c_i, c_j] = np.nan
        else:
            p_DYN_core[c_i, c_j] = len(SW_CMF[i].t[j][~np.isnan(mask_OC)]) / len(
                SW_CMF[i].t[j]
            )

        if np.all(np.isnan(mask_BMO)) or np.all(np.isnan(mask_OC)):
            p_DYN_BMO_core[c_i, c_j] = np.nan
        else:
            p_DYN_BMO_core[c_i, c_j] = len(
                SW_CMF[i].t[j][(~np.isnan(mask_BMO)) & (~np.isnan(mask_OC))]
            ) / len(SW_CMF[i].t[j])

# Figure
fig, ax = plt.subplots(1, 1, figsize=(4, 4))

p = ax.pcolormesh(
    CMF_p,
    M_p,
    BS_S_BMO_core,
    cmap="plasma_r",
    shading="auto",
    norm=mpl.colors.LogNorm(vmin=1, vmax=np.nanmax(BS_S_BMO_core)),
    rasterized=True,
)

c = ax.contour(
    CMF_p,
    M_p,
    ndimage.gaussian_filter(len_DYN_BMO, 0),
    levels=[0.1, 0.3, 0.5, 0.7, 0.9],
    cmap="winter_r",
    linestyles="dotted",
    linewidths=1.5,
)
ax.clabel(c)

c = ax.contour(
    CMF_p,
    M_p,
    ndimage.gaussian_filter(len_DYN_core, 0.6),
    levels=[0.75, 0.8, 0.85, 0.9, 0.95],
    cmap="winter_r",
    linestyles="dashed",
    linewidths=1.5,
)
ax.clabel(c)

cb = fig.colorbar(
    p,
    ax=ax,
    label="$\\langle B_{P,b} \\rangle / \\langle B_{P,c} \\rangle$",
    location="top",
)
cb.set_ticks(
    np.concatenate((np.arange(1, 10), np.arange(10, 30, 10))),
    labels=["1", "2", "", "4", "", "6", "", "8", "", "10", "20"],
)

for ii in range(is_DYN_BMO_S2020.shape[0]):
    for jj in range(is_DYN_BMO_S2020.shape[1]):
        if not is_DYN_BMO_S2020[ii, jj]:
            x_p = p.get_coordinates()[ii, jj, 0]
            y_p = p.get_coordinates()[ii, jj, 1]

            w_p = p.get_coordinates()[ii, jj + 1, 0] - p.get_coordinates()[ii, jj, 0]
            h_p = p.get_coordinates()[ii + 1, jj, 1] - p.get_coordinates()[ii, jj, 1]

            coord = np.array(
                [
                    [x_p, y_p],
                    [x_p + w_p, y_p],
                    [x_p + w_p, y_p + h_p],
                    [x_p, y_p + h_p],
                ]
            )
            poly = mpl.patches.Polygon(
                coord,
                edgecolor=tab20c(5),
                facecolor="none",
                hatch="//",
                linewidth=0,
            )
            ax.add_patch(poly)

        if not is_DYN_core_S2020[ii, jj]:
            x_p = p.get_coordinates()[ii, jj, 0]
            y_p = p.get_coordinates()[ii, jj, 1]

            w_p = p.get_coordinates()[ii, jj + 1, 0] - p.get_coordinates()[ii, jj, 0]
            h_p = p.get_coordinates()[ii + 1, jj, 1] - p.get_coordinates()[ii, jj, 1]

            coord = np.array(
                [
                    [x_p, y_p],
                    [x_p + w_p, y_p],
                    [x_p + w_p, y_p + h_p],
                    [x_p, y_p + h_p],
                ]
            )
            poly = mpl.patches.Polygon(
                coord,
                edgecolor=tab20c(16),
                facecolor="none",
                hatch=r"\\",
                linewidth=0,
            )
            ax.add_patch(poly)

ax.set_xlabel("CMF")
ax.set_ylabel("$M_P/M_{\\oplus}$")
ax.set_xticks(CMF_p)
ax.set_xticklabels(CMF_p)
ax.set_yticks(M_p)
ax.set_yticklabels(M_p.astype(int))

handles = [
    mpl.patches.Rectangle(
        (0, 0),
        1,
        1,
        edgecolor=tab20c(5),
        facecolor="none",
        linewidth=0,
        hatch="///",
    ),
    mpl.patches.Rectangle(
        (0, 0),
        1,
        1,
        edgecolor=tab20c(16),
        facecolor="none",
        linewidth=0,
        hatch=r"\\\\",
    ),
]
labels = ["no BMO dynamo", "no core dynamo"]
ax.legend(
    handles,
    labels,
    loc="lower center",
    frameon=False,
    ncol=2,
    bbox_to_anchor=(0.5, -0.3),
)

if save_fig:
    fig.savefig(save_path + "/main_magnetic_ratio.pdf")

# %% SI: Nominal structure
# =============================================================================
# f(M, CMF) @ t = 0
fig, ax = plt.subplots(4, 2, figsize=(7, 8), sharex="col", constrained_layout=True)

n, j = 1, 0
for m in range(len(SW_M[n].sw_val)):
    i = 0
    ax[i, j].plot(
        SW_M[n].radius[m][0] / 1e3,
        SW_M[n].rho[m][0],
        color=viridis(len(SW_M[n].sw_val))[m],
    )
    ax[i, j].plot(
        SW_M[n].radius_BMO_r_0_i[m][0] / 1e3,
        SW_M[n].rho_BMO_r_0_i[m][0],
        "--",
        color=viridis(len(SW_M[n].sw_val))[m],
    )
    if n == 1 and m == 0:
        ax[i, j].plot(
            r_PREM / 1e3,
            PREM_density(r_PREM),
            "k--",
        )
    if m == 0:
        ax[i, j].set_ylabel("$\\rho$ ($\\mathrm{kg.m^{-3}}$)")
        ax[i, j].set_title("$\\mathrm{CMF}=$" + "${:.2f}$".format(CMF_M[n]))
        ax[i, j].grid()

    i = 1
    ax[i, j].plot(
        SW_M[n].radius[m][0] / 1e3,
        SW_M[n].g[m][0],
        color=viridis(len(SW_M[n].sw_val))[m],
    )
    ax[i, j].plot(
        SW_M[n].radius_BMO_r_0_i[m][0] / 1e3,
        SW_M[n].g_BMO_r_0_i[m][0],
        "--",
        color=viridis(len(SW_M[n].sw_val))[m],
    )
    if n == 1 and m == 0:
        ax[i, j].plot(
            r_PREM / 1e3,
            PREM_gravity(r_PREM),
            "k--",
        )
    if m == 0:
        ax[i, j].set_ylabel("$g$ ($\\mathrm{m.s^{-2}}$)")
        ax[i, j].grid()

    i = 2
    ax[i, j].plot(
        SW_M[n].radius[m][0] / 1e3,
        SW_M[n].P[m][0] / 1e9,
        color=viridis(len(SW_M[n].sw_val))[m],
    )
    ax[i, j].plot(
        SW_M[n].radius_BMO_r_0_i[m][0] / 1e3,
        SW_M[n].P_BMO_r_0_i[m][0] / 1e9,
        "--",
        color=viridis(len(SW_M[n].sw_val))[m],
    )
    if n == 1 and m == 0:
        ax[i, j].plot(
            r_PREM / 1e3,
            PREM_pressure(r_PREM) / 1e9,
            "k--",
        )
    if m == 0:
        ax[i, j].set_ylabel("$P$ (GPa)")
        ax[i, j].grid()

    i = 3
    ax[i, j].plot(
        SW_M[n].radius_core[m][0] / 1e3,
        SW_M[n].T_core[m][0],
        color=viridis(len(SW_M[n].sw_val))[m],
    )
    ax[i, j].plot(
        SW_M[n].radius_BMO_r_0[m][0] / 1e3,
        SW_M[n].Ta_BMO_r_0[m][0],
        "--",
        color=viridis(len(SW_M[n].sw_val))[m],
    )
    ax[i, j].plot(
        SW_M[n].radius_mantle[m][0] / 1e3,
        SW_M[n].T_mantle[m][0],
        color=viridis(len(SW_M[n].sw_val))[m],
    )
    ax[i, j].plot(
        SW_M[n].radius_silicate[m][0] / 1e3,
        SW_M[n].Tm_mantle[m][0],
        ":",
        color=viridis(len(SW_M[n].sw_val))[m],
    )
    ax[i, j].plot(
        SW_M[n].radius_core[m][0] / 1e3,
        SW_M[n].Tm_core[m][0],
        "-.",
        color=viridis(len(SW_M[n].sw_val))[m],
    )
    if m == 0:
        ax[i, j].set_ylabel("$T$ (K)")
        ax[i, j].grid()

ax[i, j].set_xlabel("$r$ (km)")

ax_cbar = fig.add_axes([0.13, -0.02, 0.35, 0.02])
levels = np.linspace(0, 1, len(SW_M[1].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])
cbar = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="$M_P/M_{\\oplus}$",
    orientation="horizontal",
)
cbar.ax.set_xticks(midpoints)
cbar.ax.set_xticklabels(SW_M[n].sw_val.astype(int))

n, j = 3, 1
for m in range(len(SW_CMF[n].sw_val)):
    i = 0
    ax[i, j].plot(
        SW_CMF[n].radius[m][0] / 1e3,
        SW_CMF[n].rho[m][0],
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )
    ax[i, j].plot(
        SW_CMF[n].radius_BMO_r_0_i[m][0] / 1e3,
        SW_CMF[n].rho_BMO_r_0_i[m][0],
        "--",
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )
    if m == 0:
        ax[i, j].set_title("$M_P={:.0f}$ ".format(M_CMF[n]) + "$M_{\\oplus}$")
        ax[i, j].grid()

    i = 1
    ax[i, j].plot(
        SW_CMF[n].radius[m][0] / 1e3,
        SW_CMF[n].g[m][0],
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )
    ax[i, j].plot(
        SW_CMF[n].radius_BMO_r_0_i[m][0] / 1e3,
        SW_CMF[n].g_BMO_r_0_i[m][0],
        "--",
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )
    if m == 0:
        ax[i, j].grid()

    i = 2
    ax[i, j].plot(
        SW_CMF[n].radius[m][0] / 1e3,
        SW_CMF[n].P[m][0] / 1e9,
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )
    ax[i, j].plot(
        SW_CMF[n].radius_BMO_r_0_i[m][0] / 1e3,
        SW_CMF[n].P_BMO_r_0_i[m][0] / 1e9,
        "--",
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )
    if m == 0:
        ax[i, j].grid()

    i = 3
    ax[i, j].plot(
        SW_CMF[n].radius_core[m][0] / 1e3,
        SW_CMF[n].T_core[m][0],
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )
    ax[i, j].plot(
        SW_CMF[n].radius_BMO_r_0[m][0] / 1e3,
        SW_CMF[n].Ta_BMO_r_0[m][0],
        "--",
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )
    ax[i, j].plot(
        SW_CMF[n].radius_mantle[m][0] / 1e3,
        SW_CMF[n].T_mantle[m][0],
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )
    ax[i, j].plot(
        SW_CMF[n].radius_silicate[m][0] / 1e3,
        SW_CMF[n].Tm_mantle[m][0],
        ":",
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )
    ax[i, j].plot(
        SW_CMF[n].radius_core[m][0] / 1e3,
        SW_CMF[n].Tm_core[m][0],
        "-.",
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )
    if m == 0:
        ax[i, j].grid()

ax[i, j].set_xlabel("$r$ (km)")

ax_cbar = fig.add_axes([0.61, -0.02, 0.35, 0.02])
levels = np.linspace(0, 1, len(SW_CMF[3].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])
cbar = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="CMF",
    orientation="horizontal",
)
cbar.ax.set_xticks(midpoints)
cbar.ax.set_xticklabels(SW_CMF[n].sw_val)

subplots_label(ax)
if save_fig:
    fig.savefig(save_path + "/SI_structure_M_CMF.pdf")


# %% f(t) @ M = {1, 4, 8} & CMF = 0.32
fig, ax = plt.subplots(4, 3, figsize=(8, 8), constrained_layout=True)

n = 1
m_p = np.array([0, 3, 7])

color = viridis(len(SW_M[n].radius[0]))

for m in range(len(m_p)):
    for l in range(len(SW_M[n].radius[m_p[m]])):
        i = 0
        ax[i, m].plot(
            SW_M[n].radius[m_p[m]][l] / 1e3,
            SW_M[n].rho[m_p[m]][l],
            color=color[l],
        )
        ax[i, m].plot(
            SW_M[n].radius_BMO_r_0_i[m_p[m]][l] / 1e3,
            SW_M[n].rho_BMO_r_0_i[m_p[m]][l],
            "--",
            color=color[l],
        )
        if m == 0 and l == 0:
            ax[i, m].plot(
                r_PREM / 1e3,
                PREM_density(r_PREM),
                "k--",
            )

        if m == 0 and l == 0:
            ax[i, m].set_ylabel("$\\rho$ ($\\mathrm{kg.m^{-3}}$)")
        if l == 0:
            ax[i, m].set_title(
                "$M_P={:.0f}$ ".format(SW_M[n].sw_val[m_p[m]]) + "$M_{\\oplus}$"
            )
        if l == 0:
            ax[i, m].grid()

        i = 1
        ax[i, m].plot(
            SW_M[n].radius[m_p[m]][l] / 1e3,
            SW_M[n].g[m_p[m]][l],
            color=color[l],
        )
        ax[i, m].plot(
            SW_M[n].radius_BMO_r_0_i[m_p[m]][l] / 1e3,
            SW_M[n].g_BMO_r_0_i[m_p[m]][l],
            "--",
            color=color[l],
        )
        if m == 0 and l == 0:
            ax[i, m].plot(
                r_PREM / 1e3,
                PREM_gravity(r_PREM),
                "k--",
            )
        if m == 0 and l == 0:
            ax[i, m].set_ylabel("$g$ ($\\mathrm{m.s^{-2}}$)")
        if l == 0:
            ax[i, m].grid()

        i = 2
        ax[i, m].plot(
            SW_M[n].radius[m_p[m]][l] / 1e3,
            SW_M[n].P[m_p[m]][l] / 1e9,
            color=color[l],
        )
        ax[i, m].plot(
            SW_M[n].radius_BMO_r_0_i[m_p[m]][l] / 1e3,
            SW_M[n].P_BMO_r_0_i[m_p[m]][l] / 1e9,
            "--",
            color=color[l],
        )
        if m == 0 and l == 0:
            ax[i, m].plot(
                r_PREM / 1e3,
                PREM_pressure(r_PREM) / 1e9,
                "k--",
            )
        if m == 0 and l == 0:
            ax[i, m].set_ylabel("$P$ (GPa)")
        if l == 0:
            ax[i, m].grid()

        i = 3
        ax[i, m].plot(
            SW_M[n].radius_core[m_p[m]][l] / 1e3,
            SW_M[n].T_core[m_p[m]][l],
            color=color[l],
        )
        ax[i, m].plot(
            SW_M[n].radius_BMO_r_0[m_p[m]][l] / 1e3,
            SW_M[n].Ta_BMO_r_0[m_p[m]][l],
            "--",
            color=color[l],
        )
        ax[i, m].plot(
            SW_M[n].radius_mantle[m_p[m]][l] / 1e3,
            SW_M[n].T_mantle[m_p[m]][l],
            color=color[l],
        )
        ax[i, m].plot(
            SW_M[n].radius_silicate[m_p[m]][l] / 1e3,
            SW_M[n].Tm_mantle[m_p[m]][l],
            ":",
            color=color[l],
        )
        ax[i, m].plot(
            SW_M[n].radius_core[m_p[m]][l] / 1e3,
            SW_M[n].Tm_core[m_p[m]][l],
            "-.",
            color=color[l],
        )
        if m == 0 and l == 0:
            ax[i, m].set_ylabel("$T$ (K)")
        if l == 0:
            ax[i, m].grid()

    ax[i, m].set_xlabel("$r$ (km)")

ax_cbar = fig.add_axes([0.15, -0.025, 0.7, 0.015])
fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.Normalize(vmin=0, vmax=s2y(SW_M[n].t[0][-1]) / 1e9),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="$t$ ($\mathrm{Gyr}$)",
    orientation="horizontal",
)

subplots_label(ax)
if save_fig:
    fig.savefig(save_path + "/SI_structure_time_M.pdf")

# %% SI: Nominal thermodynamic quantities
# =============================================================================
# f(M, CMF) @ t = 0
fig, ax = plt.subplots(4, 2, figsize=(7, 8), sharex="col", constrained_layout=True)

n, j = 1, 0
for m in range(len(SW_M[n].sw_val)):
    i = 0
    ax[i, j].plot(
        SW_M[n].radius[m][0] / 1e3,
        SW_M[n].gamma[m][0],
        color=viridis(len(SW_M[n].sw_val))[m],
    )
    ax[i, j].plot(
        SW_M[n].radius_BMO_r_0_i[m][0] / 1e3,
        SW_M[n].gamma_BMO_r_0_i[m][0],
        "--",
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel("$\\gamma$")
        ax[i, j].set_title("$\\mathrm{CMF}=$" + "${:.2f}$".format(CMF_M[n]))
        ax[i, j].grid()

    i = 1
    ax[i, j].plot(
        SW_M[n].radius[m][0] / 1e3,
        SW_M[n].alpha[m][0] / 1e-5,
        color=viridis(len(SW_M[n].sw_val))[m],
    )
    ax[i, j].plot(
        SW_M[n].radius_BMO_r_0_i[m][0] / 1e3,
        SW_M[n].alpha_BMO_r_0_i[m][0] / 1e-5,
        "--",
        color=viridis(len(SW_M[n].sw_val))[m],
    )
    if m == 0:
        ax[i, j].set_ylabel("$\\alpha$ ($10^{-5}~\\mathrm{K^{-1}}$)")
        ax[i, j].grid()

    i = 2
    ax[i, j].plot(
        SW_M[n].radius[m][0] / 1e3,
        SW_M[n].KT[m][0] / 1e9,
        color=viridis(len(SW_M[n].sw_val))[m],
    )
    ax[i, j].plot(
        SW_M[n].radius_BMO_r_0_i[m][0] / 1e3,
        SW_M[n].KT_BMO_r_0_i[m][0] / 1e9,
        "--",
        color=viridis(len(SW_M[n].sw_val))[m],
    )
    if m == 0:
        ax[i, j].set_ylabel("$K_T$ (GPa)")
        ax[i, j].grid()

    i = 3
    ax[i, j].plot(
        SW_M[n].radius[m][0] / 1e3,
        SW_M[n].Cp[m][0],
        color=viridis(len(SW_M[n].sw_val))[m],
    )
    ax[i, j].plot(
        SW_M[n].radius_BMO_r_0_i[m][0] / 1e3,
        SW_M[n].Cp_BMO_r_0_i[m][0],
        "--",
        color=viridis(len(SW_M[n].sw_val))[m],
    )
    if m == 0:
        ax[i, j].set_ylabel("$c_P$ ($\\mathrm{J.kg^{-1}.K^{-1}}$)")
        ax[i, j].grid()

ax[i, j].set_xlabel("$r$ (km)")

ax_cbar = fig.add_axes([0.13, -0.02, 0.35, 0.02])
levels = np.linspace(0, 1, len(SW_M[1].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])
cbar = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="$M_P/M_{\\oplus}$",
    orientation="horizontal",
)
cbar.ax.set_xticks(midpoints)
cbar.ax.set_xticklabels(SW_M[n].sw_val.astype(int))

n, j = 3, 1
for m in range(len(SW_CMF[n].sw_val)):
    i = 0
    ax[i, j].plot(
        SW_CMF[n].radius[m][0] / 1e3,
        SW_CMF[n].gamma[m][0],
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )
    ax[i, j].plot(
        SW_CMF[n].radius_BMO_r_0_i[m][0] / 1e3,
        SW_CMF[n].gamma_BMO_r_0_i[m][0],
        "--",
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )
    if m == 0:
        ax[i, j].set_title("$M_P={:.0f}$ ".format(M_CMF[n]) + "$M_{\\oplus}$")
        ax[i, j].grid()

    i = 1
    ax[i, j].plot(
        SW_CMF[n].radius[m][0] / 1e3,
        SW_CMF[n].alpha[m][0] / 1e-5,
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )
    ax[i, j].plot(
        SW_CMF[n].radius_BMO_r_0_i[m][0] / 1e3,
        SW_CMF[n].alpha_BMO_r_0_i[m][0] / 1e-5,
        "--",
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )
    if m == 0:
        ax[i, j].grid()

    i = 2
    ax[i, j].plot(
        SW_CMF[n].radius[m][0] / 1e3,
        SW_CMF[n].KT[m][0] / 1e9,
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )
    ax[i, j].plot(
        SW_CMF[n].radius_BMO_r_0_i[m][0] / 1e3,
        SW_CMF[n].KT_BMO_r_0_i[m][0] / 1e9,
        "--",
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )
    if m == 0:
        ax[i, j].grid()

    i = 3
    ax[i, j].plot(
        SW_CMF[n].radius[m][0] / 1e3,
        SW_CMF[n].Cp[m][0],
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )
    ax[i, j].plot(
        SW_CMF[n].radius_BMO_r_0_i[m][0] / 1e3,
        SW_CMF[n].Cp_BMO_r_0_i[m][0],
        "--",
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )
    if m == 0:
        ax[i, j].grid()

ax[i, j].set_xlabel("$r$ (km)")

ax_cbar = fig.add_axes([0.61, -0.02, 0.35, 0.02])
levels = np.linspace(0, 1, len(SW_CMF[3].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])
cbar = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="CMF",
    orientation="horizontal",
)
cbar.ax.set_xticks(midpoints)
cbar.ax.set_xticklabels(SW_CMF[n].sw_val)

subplots_label(ax)
if save_fig:
    fig.savefig(save_path + "/SI_thermodynamic_M_CMF.pdf")

# %% f(t) @ M = {1, 4, 8} & CMF = 0.32
fig, ax = plt.subplots(4, 3, figsize=(8, 8), constrained_layout=True)

n = 1
m_p = np.array([0, 3, 7])

color = viridis(len(SW_M[n].radius[0]))

for m in range(len(m_p)):
    for l in range(len(SW_M[n].radius[m_p[m]])):
        i = 0
        ax[i, m].plot(
            SW_M[n].radius[m_p[m]][l] / 1e3,
            SW_M[n].gamma[m_p[m]][l],
            color=color[l],
        )
        ax[i, m].plot(
            SW_M[n].radius_BMO_r_0_i[m_p[m]][l] / 1e3,
            SW_M[n].gamma_BMO_r_0_i[m_p[m]][l],
            "--",
            color=color[l],
        )

        if m == 0 and l == 0:
            ax[i, m].set_ylabel("$\\gamma$")
        if l == 0:
            ax[i, m].set_title(
                "$M_P={:.0f}$ ".format(SW_M[n].sw_val[m_p[m]]) + "$M_{\\oplus}$"
            )
        if l == 0:
            ax[i, m].grid()

        i = 1
        ax[i, m].plot(
            SW_M[n].radius[m_p[m]][l] / 1e3,
            SW_M[n].alpha[m_p[m]][l] / 1e-5,
            color=color[l],
        )
        ax[i, m].plot(
            SW_M[n].radius_BMO_r_0_i[m_p[m]][l] / 1e3,
            SW_M[n].alpha_BMO_r_0_i[m_p[m]][l] / 1e-5,
            "--",
            color=color[l],
        )
        if m == 0 and l == 0:
            ax[i, m].set_ylabel("$\\alpha$ ($10^{-5}~\\mathrm{K^{-1}}$)")
        if l == 0:
            ax[i, m].grid()

        i = 2
        ax[i, m].plot(
            SW_M[n].radius[m_p[m]][l] / 1e3,
            SW_M[n].KT[m_p[m]][l] / 1e9,
            color=color[l],
        )
        ax[i, m].plot(
            SW_M[n].radius_BMO_r_0_i[m_p[m]][l] / 1e3,
            SW_M[n].KT_BMO_r_0_i[m_p[m]][l] / 1e9,
            "--",
            color=color[l],
        )
        if m == 0 and l == 0:
            ax[i, m].set_ylabel("$K_T$ (GPa)")
        if l == 0:
            ax[i, m].grid()

        i = 3
        ax[i, m].plot(
            SW_M[n].radius[m_p[m]][l] / 1e3,
            SW_M[n].Cp[m_p[m]][l],
            color=color[l],
        )
        ax[i, m].plot(
            SW_M[n].radius_BMO_r_0[m_p[m]][l] / 1e3,
            SW_M[n].Cp_BMO_r_0_i[m_p[m]][l],
            "--",
            color=color[l],
        )
        if m == 0 and l == 0:
            ax[i, m].set_ylabel("$c_P$ ($\\mathrm{J.kg^{-1}.K^{-1}}$)")
        if l == 0:
            ax[i, m].grid()

    ax[i, m].set_xlabel("$r$ (km)")

ax_cbar = fig.add_axes([0.15, -0.025, 0.7, 0.015])
fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.Normalize(vmin=0, vmax=s2y(SW_M[n].t[0][-1]) / 1e9),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="$t$ ($\mathrm{Gyr}$)",
    orientation="horizontal",
)

subplots_label(ax)
if save_fig:
    fig.savefig(save_path + "/SI_thermodynamic_time_M.pdf")

# %% SI: Mantle transport properties
# =============================================================================
# f(M, CMF) @ t = 0
fig, ax = plt.subplots(2, 2, figsize=(7, 6), sharex="col", constrained_layout=True)

n, j = 1, 0

for m in range(len(SW_M[n].sw_val)):
    i = 0
    ax[i, j].plot(
        SW_M[n].radius_mantle[m][0] / 1e3,
        eta_solid(SW_M[n].Ta_mantle[m][0], SW_M[n].sw_val[m], CMF_M[n]),
        color=viridis(len(SW_M[n].sw_val))[m],
    )
    if m == 0:
        ax[i, j].set_ylabel("$\mu$ (Pa.s)")
        ax[i, j].set_yscale("log")
        ax[i, j].set_title("$\\mathrm{CMF}=$" + "${:.2f}$".format(CMF_M[n]))
        ax[i, j].grid()

    i = 1
    ax[i, j].plot(
        SW_M[n].radius_mantle[m][0] / 1e3,
        SW_M[n].k_mantle[m][0],
        color=viridis(len(SW_M[n].sw_val))[m],
    )
    if m == 0:
        ax[i, j].set_ylabel("$k$ ($\\mathrm{W.m^{-1}.K^{-1}}$)")
        ax[i, j].grid()

ax[i, j].set_xlabel("$r$ (km)")
ax[i, j].tick_params(axis="x", which="major", labelsize=9)

ax_cbar = fig.add_axes([0.11, -0.025, 0.38, 0.025])

levels = np.linspace(0, 1, len(SW_M[n].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])

cb = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="$M_P/M_{\\oplus}$",
    orientation="horizontal",
)
cb.ax.set_xticks(midpoints)
cb.ax.set_xticklabels(SW_M[n].sw_val.astype(int))

n, j = 3, 1

for m in range(len(SW_CMF[n].sw_val)):
    i = 0
    ax[i, j].plot(
        SW_CMF[n].radius_mantle[m][0] / 1e3,
        eta_solid(SW_CMF[n].Ta_mantle[m][0], M_CMF[n], SW_CMF[n].sw_val[m]),
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )
    if m == 0:
        ax[i, j].set_title("$M_P={:.0f}$ ".format(M_CMF[n]) + "$M_{\\oplus}$")
        ax[i, j].set_yscale("log")
        ax[i, j].grid()

    i = 1
    ax[i, j].plot(
        SW_CMF[n].radius_mantle[m][0] / 1e3,
        SW_CMF[n].k_mantle[m][0],
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )
    if m == 0:
        ax[i, j].grid()

ax[i, j].set_xlabel("$r$ (km)")
ax[i, j].tick_params(axis="x", which="major", labelsize=9)

ax_cbar = fig.add_axes([0.59, -0.025, 0.38, 0.025])

levels = np.linspace(0, 1, len(SW_CMF[n].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])

cb = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="CMF",
    orientation="horizontal",
)
cb.ax.set_xticks(midpoints)
cb.ax.set_xticklabels(SW_CMF[n].sw_val)

subplots_label(ax)
if save_fig:
    fig.savefig(save_path + "/SI_transport_M_CMF.pdf")

# %% f(t) @ M = {1, 4, 8} & CMF = 0.32
fig, ax = plt.subplots(2, 3, figsize=(8, 5), constrained_layout=True)

n = 1
m_p = np.array([0, 3, 7])

color = viridis(len(SW_M[n].radius[0]))

for m in range(len(m_p)):
    for l in range(len(SW_M[n].radius[m_p[m]])):
        i = 0
        ax[i, m].plot(
            SW_M[n].radius_mantle[m_p[m]][l] / 1e3,
            eta_solid(SW_M[n].Ta_mantle[m_p[m]][l], SW_M[n].sw_val[m_p[m]], CMF_M[n]),
            color=color[l],
        )

        if m == 0 and l == 0:
            ax[i, m].set_ylabel("$\mu$ (Pa.s)")
        if l == 0:
            ax[i, m].set_yscale("log")
        if l == 0:
            ax[i, m].set_title(
                "$M_P={:.0f}$ ".format(SW_M[n].sw_val[m_p[m]]) + "$M_{\\oplus}$"
            )
        if l == 0:
            ax[i, m].grid()

        i = 1
        ax[i, m].plot(
            SW_M[n].radius_mantle[m_p[m]][l] / 1e3,
            SW_M[n].k_mantle[m_p[m]][l],
            color=color[l],
        )
        if m == 0 and l == 0:
            ax[i, m].set_ylabel("$k$ ($\\mathrm{W.m^{-1}.K^{-1}}$)")
        if l == 0:
            ax[i, m].grid()

    ax[i, m].set_xlabel("$r$ (km)")

ax_cbar = fig.add_axes([0.15, -0.035, 0.7, 0.025])
fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.Normalize(vmin=0, vmax=s2y(SW_M[n].t[0][-1]) / 1e9),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="$t$ ($\mathrm{Gyr}$)",
    orientation="horizontal",
)

subplots_label(ax)
if save_fig:
    fig.savefig(save_path + "/SI_transport_time_M.pdf")

# %% SI: Nominal evolution
# =============================================================================
# Layers
fig, ax = plt.subplots(4, 2, figsize=(7, 8), sharex=True, constrained_layout=True)

n, j = 1, 0
for m in range(len(SW_M[n].sw_val)):
    mask_OC = np.where(SW_M[n].L_OC[m] > 0, 1, np.nan)

    i = 0
    ax[i, j].plot(
        s2y(SW_M[n].t[m][mask_BMO_M[n][m]]) / 1e9,
        SW_M[n].L_BMO[m][mask_BMO_M[n][m]] / 1e3,
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel("$L_b$ ($\\mathrm{km}$)")
        ax[i, j].set_title("$\\mathrm{CMF}=$" + "${:.2f}$".format(CMF_M[n]))
        ax[i, j].grid()

    i = 1
    ax[i, j].plot(
        s2y(SW_M[n].t[m]) / 1e9,
        SW_M[n].L_OC[m] / 1e3 * mask_OC,
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel("$L_c$ ($\\mathrm{km}$)")
        ax[i, j].grid()

    i = 2
    ax[i, j].plot(
        s2y(SW_M[n].t[m][mask_BMO_M[n][m]]) / 1e9,
        SW_M[n].L_BMO[m][mask_BMO_M[n][m]] / SW_M[n].R_planet[m][mask_BMO_M[n][m]],
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel("$L_b/R_P$")
        ax[i, j].grid()

    i = 3
    ax[i, j].plot(
        s2y(SW_M[n].t[m]) / 1e9,
        SW_M[n].L_OC[m] / SW_M[n].R_planet[m] * mask_OC,
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel("$L_c/R_P$")
        ax[i, j].grid()

ax[i, j].set_xlabel("$t$ (Gyr)")
ax[i, j].set_xlim(0, 10)

ax_cbar = fig.add_axes([0.11, -0.025, 0.38, 0.025])

levels = np.linspace(0, 1, len(SW_M[n].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])

cb = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="$M_P/M_{\\oplus}$",
    orientation="horizontal",
)
cb.ax.set_xticks(midpoints)
cb.ax.set_xticklabels(SW_M[n].sw_val.astype(int))

n, j = 3, 1
for m in range(len(SW_CMF[n].sw_val)):
    mask_OC = np.where(SW_CMF[n].L_OC[m] > 0, 1, np.nan)

    i = 0
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m][mask_BMO_CMF[n][m]]) / 1e9,
        SW_CMF[n].L_BMO[m][mask_BMO_CMF[n][m]] / 1e3,
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_title("$M_P={:.0f}$ ".format(M_CMF[n]) + "$M_{\\oplus}$")
        ax[i, j].grid()

    i = 1
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m]) / 1e9,
        SW_CMF[n].L_OC[m] / 1e3 * mask_OC,
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].grid()

    i = 2
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m][mask_BMO_CMF[n][m]]) / 1e9,
        SW_CMF[n].L_BMO[m][mask_BMO_CMF[n][m]]
        / SW_CMF[n].R_planet[m][mask_BMO_CMF[n][m]],
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].grid()

    i = 3
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m]) / 1e9,
        SW_CMF[n].L_OC[m] / SW_CMF[n].R_planet[m] * mask_OC,
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].grid()

ax[i, j].set_xlabel("$t$ (Gyr)")

ax_cbar = fig.add_axes([0.59, -0.025, 0.38, 0.025])

levels = np.linspace(0, 1, len(SW_CMF[n].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])

cb = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="CMF",
    orientation="horizontal",
)
cb.ax.set_xticks(midpoints)
cb.ax.set_xticklabels(SW_CMF[n].sw_val)

subplots_label(ax)
if save_fig:
    fig.savefig(save_path + "/SI_evolution_layers.pdf")

# %% Radius
fig, ax = plt.subplots(4, 2, figsize=(7, 8), sharex=True, constrained_layout=True)

n, j = 1, 0
for m in range(len(SW_M[n].sw_val)):
    i = 0
    ax[i, j].plot(
        s2y(SW_M[n].t[m]) / 1e9,
        SW_M[n].R_planet[m] / 1e3,
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel("$R_{P}$ (km)")
        ax[i, j].set_title("$\\mathrm{CMF}=$" + "${:.2f}$".format(CMF_M[n]))
        ax[i, j].grid()

    i = 1
    ax[i, j].plot(
        s2y(SW_M[n].t[m][mask_BMO_M[n][m]]) / 1e9,
        SW_M[n].R_BMO[m][mask_BMO_M[n][m]] / 1e3,
        color=viridis(len(SW_M[n].sw_val))[m],
        label="$M_P={:.0f}$ ".format(SW_M[n].sw_val[m]) + "$M_{\\oplus}$",
    )

    if m == 0:
        ax[i, j].set_ylabel("$R_{BMO}$ (km)")
        ax[i, j].grid()

    i = 2
    ax[i, j].plot(
        s2y(SW_M[n].t[m]) / 1e9,
        SW_M[n].R_CMB[m] / 1e3,
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel("$R_{CMB}$ (km)")
        ax[i, j].grid()

    i = 3
    ax[i, j].plot(
        s2y(SW_M[n].t[m]) / 1e9,
        SW_M[n].R_ICB[m] / 1e3,
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel("$R_{ICB}$ (km)")
        ax[i, j].grid()

ax[i, j].set_xlabel("$t$ (Gyr)")
ax[i, j].set_xlim(0, 10)

ax_cbar = fig.add_axes([0.13, -0.02, 0.35, 0.02])

levels = np.linspace(0, 1, len(SW_M[n].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])

cb = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="$M_P/M_{\\oplus}$",
    orientation="horizontal",
)
cb.ax.set_xticks(midpoints)
cb.ax.set_xticklabels(SW_M[n].sw_val.astype(int))

n, j = 3, 1
for m in range(len(SW_CMF[n].sw_val)):
    i = 0
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m]) / 1e9,
        SW_CMF[n].R_planet[m] / 1e3,
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_title("$M_P={:.0f}$ ".format(M_CMF[n]) + "$M_{\\oplus}$")
        ax[i, j].grid()

    i = 1
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m][mask_BMO_CMF[n][m]]) / 1e9,
        SW_CMF[n].R_BMO[m][mask_BMO_CMF[n][m]] / 1e3,
        color=viridis(len(SW_CMF[n].sw_val))[m],
        label="$\\mathrm{CMF}=$" + "${:.2f}$".format(SW_CMF[n].sw_val[m]),
    )

    if m == 0:
        ax[i, j].grid()

    i = 2
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m]) / 1e9,
        SW_CMF[n].R_CMB[m] / 1e3,
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].grid()

    i = 3
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m]) / 1e9,
        SW_CMF[n].R_ICB[m] / 1e3,
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].grid()

ax[i, j].set_xlabel("$t$ (Gyr)")
ax[i, j].set_xlim(0, 10)

ax_cbar = fig.add_axes([0.61, -0.02, 0.35, 0.02])

levels = np.linspace(0, 1, len(SW_CMF[n].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])

cb = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="CMF",
    orientation="horizontal",
)
cb.ax.set_xticks(midpoints)
cb.ax.set_xticklabels(SW_CMF[n].sw_val)

subplots_label(ax)
if save_fig:
    fig.savefig(save_path + "/SI_radius.pdf")

# %% Relative radius
fig, ax = plt.subplots(
    3, 2, figsize=(7, 7), sharex=True, sharey=True, constrained_layout=True
)

n, j = 1, 0
for m in range(len(SW_M[n].sw_val)):
    i = 0
    ax[i, j].plot(
        s2y(SW_M[n].t[m][mask_BMO_M[n][m]]) / 1e9,
        SW_M[n].R_BMO[m][mask_BMO_M[n][m]] / SW_M[n].R_planet[m][mask_BMO_M[n][m]],
        color=viridis(len(SW_M[n].sw_val))[m],
        label="$M_P={:.0f}$ ".format(SW_M[n].sw_val[m]) + "$M_{\\oplus}$",
    )

    if m == 0:
        ax[i, j].set_ylabel("$R_{BMO}/R_P$")
        ax[i, j].set_title("$\\mathrm{CMF}=$" + "${:.2f}$".format(CMF_M[n]))
        ax[i, j].grid()

    i = 1
    ax[i, j].plot(
        s2y(SW_M[n].t[m]) / 1e9,
        SW_M[n].R_CMB[m] / SW_M[n].R_planet[m],
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel("$R_{CMB}/R_P$")
        ax[i, j].grid()

    i = 2
    ax[i, j].plot(
        s2y(SW_M[n].t[m]) / 1e9,
        SW_M[n].R_ICB[m] / SW_M[n].R_planet[m],
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel("$R_{ICB}/R_P$")
        ax[i, j].grid()

ax[i, j].set_xlabel("$t$ (Gyr)")
ax[i, j].set_xlim(0, 10)

ax_cbar = fig.add_axes([0.1, -0.025, 0.4, 0.025])

levels = np.linspace(0, 1, len(SW_M[n].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])

cb = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="$M_P/M_{\\oplus}$",
    orientation="horizontal",
)
cb.ax.set_xticks(midpoints)
cb.ax.set_xticklabels(SW_M[n].sw_val.astype(int))

n, j = 3, 1
for m in range(len(SW_CMF[n].sw_val)):
    i = 0
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m][mask_BMO_CMF[n][m]]) / 1e9,
        SW_CMF[n].R_BMO[m][mask_BMO_CMF[n][m]]
        / SW_CMF[n].R_planet[m][mask_BMO_CMF[n][m]],
        color=viridis(len(SW_CMF[n].sw_val))[m],
        label="$\\mathrm{CMF}=$" + "${:.2f}$".format(SW_CMF[n].sw_val[m]),
    )

    if m == 0:
        ax[i, j].set_title("$M_P={:.0f}$ ".format(M_CMF[n]) + "$M_{\\oplus}$")
        ax[i, j].grid()

    i = 1
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m]) / 1e9,
        SW_CMF[n].R_CMB[m] / SW_CMF[n].R_planet[m],
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].grid()

    i = 2
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m]) / 1e9,
        SW_CMF[n].R_ICB[m] / SW_CMF[n].R_planet[m],
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].grid()

ax[i, j].set_xlabel("$t$ (Gyr)")
ax[i, j].set_xlim(0, 10)

ax_cbar = fig.add_axes([0.56, -0.025, 0.4, 0.025])

levels = np.linspace(0, 1, len(SW_CMF[n].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])

cb = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="CMF",
    orientation="horizontal",
)
cb.ax.set_xticks(midpoints)
cb.ax.set_xticklabels(SW_CMF[n].sw_val)

subplots_label(ax)
if save_fig:
    fig.savefig(save_path + "/SI_relative_radius.pdf")

# %% SI: Temperature
fig, ax = plt.subplots(5, 2, figsize=(7, 8), sharex=True, constrained_layout=True)

n, j = 1, 0
for m in range(len(SW_M[n].sw_val)):
    i = 0
    ax[i, j].plot(
        s2y(SW_M[n].t[m]) / 1e9,
        SW_M[n].T_mantle_avg[m],
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel("$\\bar{T}_m$ (K)")
        ax[i, j].set_title("$\\mathrm{CMF}=$" + "${:.2f}$".format(CMF_M[n]))
        ax[i, j].grid()

    i = 1
    ax[i, j].plot(
        s2y(SW_M[n].t[m][mask_BMO_M[n][m]]) / 1e9,
        SW_M[n].T_BMO[m][mask_BMO_M[n][m]],
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel("$T_{BMO}$ (K)")
        ax[i, j].grid()

    i = 2
    ax[i, j].plot(
        s2y(SW_M[n].t[m]) / 1e9,
        SW_M[n].T_CMB[m],
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel("$T_{CMB}$ (K)")
        ax[i, j].grid()

    i = 3
    ax[i, j].plot(
        s2y(SW_M[n].t[m]) / 1e9,
        SW_M[n].T_ICB[m],
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel("$T_{ICB}$ (K)")
        ax[i, j].grid()

    i = 4
    ax[i, j].plot(
        s2y(SW_M[n].t[m]) / 1e9,
        SW_M[n].T_center[m],
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel("$T_{C}$ (K)")
        ax[i, j].grid()

ax[i, j].set_xlabel("$t$ (Gyr)")
ax[i, j].set_xlim(0, 10)

ax_cbar = fig.add_axes([0.13, -0.02, 0.35, 0.02])
levels = np.linspace(0, 1, len(SW_M[1].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])
cbar = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="$M_P/M_{\\oplus}$",
    orientation="horizontal",
)
cbar.ax.set_xticks(midpoints)
cbar.ax.set_xticklabels(SW_M[n].sw_val.astype(int))

n, j = 3, 1
for m in range(len(SW_CMF[n].sw_val)):
    i = 0
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m]) / 1e9,
        SW_CMF[n].T_mantle_avg[m],
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_title("$M_P={:.0f}$ ".format(M_CMF[n]) + "$M_{\\oplus}$")
        ax[i, j].grid()

    i = 1
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m][mask_BMO_CMF[n][m]]) / 1e9,
        SW_CMF[n].T_BMO[m][mask_BMO_CMF[n][m]],
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].grid()

    i = 2
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m]) / 1e9,
        SW_CMF[n].T_CMB[m],
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].grid()

    i = 3
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m]) / 1e9,
        SW_CMF[n].T_ICB[m],
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].grid()

    i = 4
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m]) / 1e9,
        SW_CMF[n].T_center[m],
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].grid()

ax[i, j].set_xlabel("$t$ (Gyr)")

ax_cbar = fig.add_axes([0.61, -0.02, 0.35, 0.02])
levels = np.linspace(0, 1, len(SW_CMF[3].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])
cbar = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="CMF",
    orientation="horizontal",
)
cbar.ax.set_xticks(midpoints)
cbar.ax.set_xticklabels(SW_CMF[n].sw_val)

subplots_label(ax)
if save_fig:
    fig.savefig(save_path + "/SI_evolution_temperature.pdf")

# %% SI: Composition
fig, ax = plt.subplots(2, 2, figsize=(7, 6), sharex=True, constrained_layout=True)

n, j = 1, 0
for m in range(len(SW_M[n].sw_val)):
    mask_OC = np.where(SW_M[n].L_OC[m] > 0, 1, np.nan)

    i_Xi_core_filt = np.argwhere(SW_M[n].Xi_core[m] > 1).flatten()
    if len(i_Xi_core_filt) > 0:
        i_Xi_core_filt = i_Xi_core_filt[0] + 1
    else:
        i_Xi_core_filt = -1

    i = 0
    ax[i, j].plot(
        s2y(SW_M[n].t[m][mask_BMO_M[n][m]]) / 1e9,
        SW_M[n].Xi_BMO[m][mask_BMO_M[n][m]],
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel("$\\xi_{b}$")
        ax[i, j].set_title("$\\mathrm{CMF}=$" + "${:.2f}$".format(CMF_M[n]))
        ax[i, j].grid()

    i = 1
    ax[i, j].plot(
        s2y(SW_M[n].t[m])[:i_Xi_core_filt] / 1e9,
        SW_M[n].Xi_core[m][:i_Xi_core_filt] * mask_OC[:i_Xi_core_filt],
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel("$\\xi_{c}$")
        ax[i, j].grid()

ax[i, j].set_xlabel("$t$ (Gyr)")
ax[i, j].set_xlim(0, 10)

ax_cbar = fig.add_axes([0.11, -0.025, 0.38, 0.025])

levels = np.linspace(0, 1, len(SW_M[n].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])

cb = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="$M_P/M_{\\oplus}$",
    orientation="horizontal",
)
cb.ax.set_xticks(midpoints)
cb.ax.set_xticklabels(SW_M[n].sw_val.astype(int))

n, j = 3, 1
for m in range(len(SW_CMF[n].sw_val)):
    mask_OC = np.where(SW_CMF[n].L_OC[m] > 0, 1, np.nan)

    i_Xi_core_filt = np.argwhere(SW_CMF[n].Xi_core[m] > 1).flatten()
    if len(i_Xi_core_filt) > 0:
        i_Xi_core_filt = i_Xi_core_filt[0] + 1
    else:
        i_Xi_core_filt = -1

    i = 0
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m][mask_BMO_CMF[n][m]]) / 1e9,
        SW_CMF[n].Xi_BMO[m][mask_BMO_CMF[n][m]],
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_title("$M_P={:.0f}$ ".format(M_CMF[n]) + "$M_{\\oplus}$")
        ax[i, j].grid()

    i = 1
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m])[:i_Xi_core_filt] / 1e9,
        SW_CMF[n].Xi_core[m][:i_Xi_core_filt] * mask_OC[:i_Xi_core_filt],
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].grid()

ax[i, j].set_xlabel("$t$ (Gyr)")

ax_cbar = fig.add_axes([0.59, -0.025, 0.38, 0.025])

levels = np.linspace(0, 1, len(SW_CMF[n].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])

cb = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="CMF",
    orientation="horizontal",
)
cb.ax.set_xticks(midpoints)
cb.ax.set_xticklabels(SW_CMF[n].sw_val)

subplots_label(ax)
if save_fig:
    fig.savefig(save_path + "/SI_evolution_composition.pdf")

# %% SI: Evolution
fig, ax = plt.subplots(3, 3, figsize=(9, 6.5), sharex=True)

n = 1
m_p = np.array([0, 3, 7])

for m in range(len(m_p)):
    mask_OC = np.where(SW_M[n].L_OC[m_p[m]] > 0, 1, np.nan)

    i_Xi_core_filt = np.argwhere(SW_M[n].Xi_core[m_p[m]] > 1).flatten()
    if len(i_Xi_core_filt) > 0:
        i_Xi_core_filt = i_Xi_core_filt[0] + 1
    else:
        i_Xi_core_filt = -1

    i = 0
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]])[mask_BMO_M[n][m_p[m]]] / 1e9,
        SW_M[n].L_BMO[m_p[m]][mask_BMO_M[n][m_p[m]]] / 1e3,
        color=tab20c(5),
        label="$L_b$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]]) / 1e9,
        SW_M[n].R_ICB[m_p[m]] / 1e3,
        color=tab20c(16),
        label="$R_{ICB}$",
    )

    ax[i, m].set_title("$M_P={:.0f}$ ".format(SW_M[n].sw_val[m_p[m]]) + "$M_{\\oplus}$")
    if m == 0:
        ax[i, m].set_ylabel("$L_b, R_{ICB}$ (km)")
        ax[i, m].legend(loc="upper left", fontsize="small")
    ax[i, m].grid()

    i = 1
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]]) / 1e9,
        SW_M[n].T_mantle_avg[m_p[m]],
        color=tab20c(9),
        label="$\\bar{T}_m$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]][mask_BMO_M[n][m_p[m]]]) / 1e9,
        SW_M[n].T_BMO[m_p[m]][mask_BMO_M[n][m_p[m]]],
        color=tab20c(4),
        label="$T_{BMO}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]]) / 1e9,
        SW_M[n].T_CMB[m_p[m]],
        color=tab20c(0),
        label="$T_{CMB}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]]) / 1e9,
        SW_M[n].T_ICB[m_p[m]],
        color=tab20c(16),
        label="$T_{ICB}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]]) / 1e9,
        SW_M[n].T_center[m_p[m]],
        color=tab20c(12),
        label="$T_{C}$",
    )

    if m == 0:
        ax[i, m].set_ylabel("$T$ (K)")
        ax[i, m].legend(loc="upper right", fontsize="small")
    ax[i, m].grid()

    i = 2
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]])[mask_BMO_M[n][m_p[m]]] / 1e9,
        SW_M[n].Xi_BMO[m_p[m]][mask_BMO_M[n][m_p[m]]],
        color=tab20c(5),
        label="$\\xi_b$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]])[:i_Xi_core_filt] / 1e9,
        SW_M[n].Xi_core[m_p[m]][:i_Xi_core_filt] * mask_OC[:i_Xi_core_filt],
        color=tab20c(17),
        label="$\\xi_c$",
    )

    if m == 0:
        ax[i, m].set_ylabel("$\\xi$")
        ax[i, m].legend(loc="upper right", fontsize="small")
    ax[i, m].grid()

    ax[i, m].set_xlabel("$t$ (Gyr)")
    ax[i, m].set_xlim(0, 10)

subplots_label(ax)
if save_fig:
    fig.savefig(save_path + "/SI_evolution.pdf")

# %% SI: Transport properties
# =============================================================================
fig, ax = plt.subplots(2, 2, figsize=(7, 6), sharex=True, constrained_layout=True)

n, j = 1, 0
for m in range(len(SW_M[n].sw_val)):
    i = 0
    ax[i, j].plot(
        s2y(SW_M[n].t[m]) / 1e9,
        SW_M[n].eta_mantle[m],
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel("$\mu_m$ ($\\mathrm{Pa.s}$)")
        ax[i, j].set_title("$\\mathrm{CMF}=$" + "${:.2f}$".format(CMF_M[n]))
        ax[i, j].set_yscale("log")
        ax[i, j].grid()

    i = 1
    ax[i, j].plot(
        s2y(SW_M[n].t[m]) / 1e9,
        SW_M[n].k_mantle_avg[m],
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel("$k_m$ ($\\mathrm{W.m^{-1}.K^{-1}}$)")
        ax[i, j].grid()

ax[i, j].set_xlabel("$t$ (Gyr)")
ax[i, j].set_xlim(0, 10)

ax_cbar = fig.add_axes([0.11, -0.025, 0.38, 0.025])

levels = np.linspace(0, 1, len(SW_M[n].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])

cb = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="$M_P/M_{\\oplus}$",
    orientation="horizontal",
)
cb.ax.set_xticks(midpoints)
cb.ax.set_xticklabels(SW_M[n].sw_val.astype(int))

n, j = 3, 1
for m in range(len(SW_CMF[n].sw_val)):
    i = 0
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m]) / 1e9,
        SW_CMF[n].eta_mantle[m],
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_title("$M_P={:.0f}$ ".format(M_CMF[n]) + "$M_{\\oplus}$")
        ax[i, j].set_yscale("log")
        ax[i, j].grid()

    i = 1
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m]) / 1e9,
        SW_CMF[n].k_mantle_avg[m],
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].grid()

ax[i, j].set_xlabel("$t$ (Gyr)")

ax_cbar = fig.add_axes([0.59, -0.025, 0.38, 0.025])

levels = np.linspace(0, 1, len(SW_CMF[n].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])

cb = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="CMF",
    orientation="horizontal",
)
cb.ax.set_xticks(midpoints)
cb.ax.set_xticklabels(SW_CMF[n].sw_val)

subplots_label(ax)
if save_fig:
    fig.savefig(save_path + "/SI_evolution_transport.pdf")

# %% SI: Electrical conductivities
# =============================================================================
fig, ax = plt.subplots(2, 2, figsize=(7, 6), sharex=True, constrained_layout=True)

n, j = 1, 0
for m in range(len(SW_M[n].sw_val)):
    i = 0
    ax[i, j].plot(
        s2y(SW_M[n].t[m][mask_BMO_M[n][m]]) / 1e9,
        SW_M[n].sigma_BMO_S2020[m][mask_BMO_M[n][m]],
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel("$\sigma_b$ ($\\mathrm{S.m^{-1}}$)")
        ax[i, j].set_title("$\\mathrm{CMF}=$" + "${:.2f}$".format(CMF_M[n]))
        ax[i, j].grid()

    i = 1
    ax[i, j].plot(
        s2y(SW_M[n].t[m]) / 1e9,
        SW_M[n].sigma_core_S2020[m],
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel("$\sigma_c$ ($\\mathrm{S.m^{-1}}$)")
        ax[i, j].grid()

ax[i, j].set_xlabel("$t$ (Gyr)")
ax[i, j].set_xlim(0, 10)

ax_cbar = fig.add_axes([0.13, -0.025, 0.36, 0.025])
levels = np.linspace(0, 1, len(SW_M[n].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])
cb = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="$M_P/M_{\\oplus}$",
    orientation="horizontal",
)
cb.ax.set_xticks(midpoints)
cb.ax.set_xticklabels(SW_M[n].sw_val.astype(int))

n, j = 3, 1
for m in range(len(SW_CMF[n].sw_val)):
    i = 0
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m][mask_BMO_CMF[n][m]]) / 1e9,
        SW_CMF[n].sigma_BMO_S2020[m][mask_BMO_CMF[n][m]],
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_title("$M_P={:.0f}$ ".format(M_CMF[n]) + "$M_{\\oplus}$")
        ax[i, j].grid()

    i = 1
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m]) / 1e9,
        SW_CMF[n].sigma_core_S2020[m],
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].grid()

ax[i, j].set_xlabel("$t$ (Gyr)")
ax[i, j].set_xlim(0, 10)

ax_cbar = fig.add_axes([0.62, -0.025, 0.36, 0.025])
levels = np.linspace(0, 1, len(SW_CMF[3].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])
cbar = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="CMF",
    orientation="horizontal",
)
cbar.ax.set_xticks(midpoints)
cbar.ax.set_xticklabels(SW_CMF[n].sw_val)

subplots_label(ax)
if save_fig:
    fig.savefig(save_path + "/SI_electrical_conductivity.pdf")

# %% SI: Energy budget
# =============================================================================
# Interface heat flows
fig, ax = plt.subplots(3, 2, figsize=(7, 7), sharex=True, constrained_layout=True)

n, j = 1, 0
for m in range(len(SW_M[n].sw_val)):
    mask_OC = np.where(SW_M[n].L_OC[m] > 0, 1, np.nan)

    mask_core_art = np.ones(len(SW_M[n].t[m]), dtype=bool)
    idx = np.argwhere(SW_M[n].L_OC[m] == 0).flatten()
    if len(idx) > 0:
        mask_core_art[idx[0] - 1 : idx[0] + 1] = 0

    i = 0
    ax[i, j].plot(
        s2y(SW_M[n].t[m]) / 1e9,
        SW_M[n].Q_planet[m] / 1e12,
        color=viridis(len(SW_M[n].sw_val))[m],
    )
    ax[i, j].plot(
        s2y(SW_M[n].t[m]) / 1e9,
        SW_M[n].Q_A_mantle[m] / 1e12,
        color=viridis(len(SW_M[n].sw_val))[m],
        linestyle=":",
    )

    if m == 0:
        ax[i, j].set_ylabel("$Q_P$ (TW)")
        ax[i, j].set_title("$\\mathrm{CMF}=$" + "${:.2f}$".format(CMF_M[n]))
        ax[i, j].set_yscale("log")
        ax[i, j].grid()

    i = 1
    ax[i, j].plot(
        s2y(SW_M[n].t[m][mask_BMO_M[n][m]]) / 1e9,
        SW_M[n].Q_BMO[m][mask_BMO_M[n][m]] / 1e12,
        color=viridis(len(SW_M[n].sw_val))[m],
    )
    ax[i, j].plot(
        s2y(SW_M[n].t[m][mask_BMO_M[n][m]]) / 1e9,
        SW_M[n].Q_A_BMO_S2020[m][mask_BMO_M[n][m]] / 1e12,
        color=viridis(len(SW_M[n].sw_val))[m],
        linestyle=":",
    )

    if m == 0:
        ax[i, j].set_ylabel("$Q_{BMO}$ (TW)")
        ax[i, j].set_yscale("log")
        ax[i, j].grid()

    i = 2
    ax[i, j].plot(
        s2y(SW_M[n].t[m])[mask_core_art] / 1e9,
        SW_M[n].Q_CMB[m][mask_core_art] / 1e12,
        color=viridis(len(SW_M[n].sw_val))[m],
    )
    ax[i, j].plot(
        s2y(SW_M[n].t[m]) / 1e9,
        SW_M[n].Q_A_core[m] * mask_OC / 1e12,
        color=viridis(len(SW_M[n].sw_val))[m],
        linestyle=":",
    )

    if m == 0:
        ax[i, j].set_ylabel("$Q_{CMB}$ (TW)")
        ax[i, j].set_yscale("log")
        ax[i, j].grid()

ax[i, j].set_xlabel("$t$ (Gyr)")
ax[i, j].set_xlim(0, 10)

ax_cbar = fig.add_axes([0.11, -0.025, 0.38, 0.025])

levels = np.linspace(0, 1, len(SW_M[n].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])

cb = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="$M_P/M_{\\oplus}$",
    orientation="horizontal",
)
cb.ax.set_xticks(midpoints)
cb.ax.set_xticklabels(SW_M[n].sw_val.astype(int))

n, j = 3, 1
for m in range(len(SW_CMF[n].sw_val)):
    mask_OC = np.where(SW_CMF[n].L_OC[m] > 0, 1, np.nan)

    mask_core_art = np.ones(len(SW_CMF[n].t[m]), dtype=bool)
    idx = np.argwhere(SW_CMF[n].L_OC[m] == 0).flatten()
    if len(idx) > 0:
        mask_core_art[idx[0] - 1 : idx[0] + 1] = 0

    i = 0
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m]) / 1e9,
        SW_CMF[n].Q_planet[m] / 1e12,
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m]) / 1e9,
        SW_CMF[n].Q_A_mantle[m] / 1e12,
        color=viridis(len(SW_CMF[n].sw_val))[m],
        linestyle=":",
    )

    if m == 0:
        ax[i, j].set_title("$M_P={:.0f}$ ".format(M_CMF[n]) + "$M_{\\oplus}$")
        ax[i, j].set_yscale("log")
        ax[i, j].grid()

    i = 1
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m][mask_BMO_CMF[n][m]]) / 1e9,
        SW_CMF[n].Q_BMO[m][mask_BMO_CMF[n][m]] / 1e12,
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m][mask_BMO_CMF[n][m]]) / 1e9,
        SW_CMF[n].Q_A_BMO_S2020[m][mask_BMO_CMF[n][m]] / 1e12,
        color=viridis(len(SW_CMF[n].sw_val))[m],
        linestyle=":",
    )

    if m == 0:
        ax[i, j].set_yscale("log")
        ax[i, j].grid()

    i = 2
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m])[mask_core_art] / 1e9,
        SW_CMF[n].Q_CMB[m][mask_core_art] / 1e12,
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m]) / 1e9,
        SW_CMF[n].Q_A_core[m] * mask_OC / 1e12,
        color=viridis(len(SW_CMF[n].sw_val))[m],
        linestyle=":",
    )

    if m == 0:
        ax[i, j].set_yscale("log")
        ax[i, j].grid()

ax[i, j].set_xlabel("$t$ (Gyr)")

ax_cbar = fig.add_axes([0.59, -0.025, 0.38, 0.025])

levels = np.linspace(0, 1, len(SW_CMF[n].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])

cb = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="CMF",
    orientation="horizontal",
)
cb.ax.set_xticks(midpoints)
cb.ax.set_xticklabels(SW_CMF[n].sw_val)

subplots_label(ax)
if save_fig:
    fig.savefig(save_path + "/SI_energy_M_CMF.pdf")

# %% M = {1, 4, 8} & CMF = 0.32
fig, ax = plt.subplots(3, 3, figsize=(9, 6.5), sharex=True)

n = 1
m_p = np.array([0, 3, 7])

for m in range(len(m_p)):
    mask_OC = np.where(SW_M[n].L_OC[m_p[m]] > 0, 1, np.nan)

    mask_core_art = np.ones(len(SW_M[n].t[m_p[m]]), dtype=bool)
    idx = np.argwhere(SW_M[n].L_OC[m_p[m]] == 0).flatten()
    if len(idx) > 0:
        mask_core_art[idx[0] - 1 : idx[0] + 1] = 0

    i = 0
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]]) / 1e9,
        SW_M[n].Q_planet[m_p[m]] / 1e12,
        color=tab20c(8),
        label="$Q_{P}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]]) / 1e9,
        SW_M[n].Q_BMO[m_p[m]] / 1e12,
        color=tab20c(4),
        label="$Q_{BMO}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]]) / 1e9,
        SW_M[n].Q_R_mantle[m_p[m]] / 1e12,
        color=tab20(1),
        label="$Q_{R,m}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]]) / 1e9,
        SW_M[n].Q_S_mantle[m_p[m]] / 1e12,
        color=tab20(3),
        label="$Q_{S,m}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]]) / 1e9,
        SW_M[n].Q_A_mantle[m_p[m]] / 1e12,
        "-.",
        color=tab20(11),
        label="$Q_{A,m}$",
    )

    ax[i, m].set_title("$M_P={:.0f}$ ".format(SW_M[n].sw_val[m_p[m]]) + "$M_{\\oplus}$")
    if m == 0:
        ax[i, m].set_ylabel("$Q$ (TW)")
        ax[i, m].legend(loc="upper right", fontsize="small")
    ax[i, m].grid()

    i = 1
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]]) / 1e9,
        SW_M[n].Q_BMO[m_p[m]] / 1e12,
        color=tab20c(4),
        label="$Q_{BMO}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]])[mask_core_art] / 1e9,
        SW_M[n].Q_CMB[m_p[m]][mask_core_art] / 1e12,
        color=tab20c(0),
        label="$Q_{CMB}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]])[mask_BMO_M[n][m_p[m]]] / 1e9,
        SW_M[n].Q_R_BMO[m_p[m]][mask_BMO_M[n][m_p[m]]] / 1e12,
        color=tab20(1),
        label="$Q_{R,b}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]])[mask_BMO_M[n][m_p[m]]] / 1e9,
        SW_M[n].Q_S_BMO[m_p[m]][mask_BMO_M[n][m_p[m]]] / 1e12,
        color=tab20(3),
        label="$Q_{S,b}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]])[mask_BMO_M[n][m_p[m]]] / 1e9,
        SW_M[n].Q_G_BMO[m_p[m]][mask_BMO_M[n][m_p[m]]] / 1e12,
        color=tab20(5),
        label="$Q_{G,b}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]])[mask_BMO_M[n][m_p[m]]] / 1e9,
        SW_M[n].Q_L_BMO[m_p[m]][mask_BMO_M[n][m_p[m]]] / 1e12,
        color=tab20(7),
        label="$Q_{L,b}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]])[mask_BMO_M[n][m_p[m]]] / 1e9,
        SW_M[n].Q_A_BMO_S2020[m_p[m]][mask_BMO_M[n][m_p[m]]] / 1e12,
        "-.",
        color=tab20(11),
        label="$Q_{A,b}$",
    )

    if m == 0:
        ax[i, m].set_ylabel("$Q$ (TW)")
        ax[i, m].legend(loc="upper right", fontsize="small")
    ax[i, m].grid()

    i = 2
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]])[mask_core_art] / 1e9,
        SW_M[n].Q_CMB[m_p[m]][mask_core_art] / 1e12,
        color=tab20c(0),
        label="$Q_{CMB}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]]) / 1e9,
        SW_M[n].Q_ICB[m_p[m]] * mask_OC / 1e12,
        color=tab20c(16),
        label="$Q_{ICB}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]]) / 1e9,
        SW_M[n].Q_R_core[m_p[m]] / 1e12,
        color=tab20(1),
        label="$Q_{R,c}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]]) / 1e9,
        SW_M[n].Q_S_core[m_p[m]] / 1e12,
        color=tab20(3),
        label="$Q_{S,c}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]]) / 1e9,
        SW_M[n].Q_G_core[m_p[m]] / 1e12,
        color=tab20(5),
        label="$Q_{G,c}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]]) / 1e9,
        SW_M[n].Q_L_core[m_p[m]] / 1e12,
        color=tab20(7),
        label="$Q_{L,c}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]]) / 1e9,
        SW_M[n].Q_A_core[m_p[m]] * mask_OC / 1e12,
        "-.",
        color=tab20(11),
        label="$Q_{A,c}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]]) / 1e9,
        SW_M[n].Q_R_IC[m_p[m]] / 1e12,
        "--",
        color=tab20(1),
        label="$Q_{R,ic}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]]) / 1e9,
        SW_M[n].Q_S_IC[m_p[m]] / 1e12,
        "--",
        color=tab20(3),
        label="$Q_{S,ic}$",
    )

    if m == 0:
        ax[i, m].set_ylabel("$Q$ (TW)")
        ax[i, m].legend(loc="upper right", fontsize="small")
    ax[i, m].grid()

    ax[i, m].set_xlabel("$t$ (Gyr)")
    ax[i, m].set_xlim(0, 10)

subplots_label(ax)
if save_fig:
    fig.savefig(save_path + "/SI_energy.pdf")

# %% SI: Buoyancy profile
# =============================================================================
fig, ax = plt.subplots(4, 2, figsize=(7, 8), sharex=True, constrained_layout=True)

n, j = 1, 0
for m in range(len(SW_M[n].sw_val)):
    mask_OC = np.where(SW_M[n].L_OC[m] > 0, 1, np.nan)

    mask_core_art = np.ones(len(SW_M[n].t[m]), dtype=bool)
    idx = np.argwhere(SW_M[n].L_OC[m] == 0).flatten()
    if len(idx) > 0:
        mask_core_art[idx[0] - 1 : idx[0] + 1] = 0

    i = 0
    ax[i, j].plot(
        s2y(SW_M[n].t[m][mask_BMO_M[n][m] & mask_core_art]) / 1e9,
        SW_M[n].dC0dr_TOT_BMO_S2020_MID[m][mask_BMO_M[n][m] & mask_core_art],
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel(
            "$q_{b}[(R_{BMO}+R_{CMB})/2]$ \n ($\\mathrm{kg.m^{-2}.s^{-1}}$)",
            fontsize="small",
        )
        ax[i, j].set_title("$\\mathrm{CMF}=$" + "${:.2f}$".format(CMF_M[n]))
        ax[i, j].yaxis.get_offset_text().set_position((-0.18, 0))
        ax[i, j].grid()

    i = 1
    ax[i, j].plot(
        s2y(SW_M[n].t[m])[mask_core_art] / 1e9,
        SW_M[n].dC0dr_TOT_core_MID[m][mask_core_art] * mask_OC[mask_core_art],
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel(
            "$q_{c}[(R_{CMB}+R_{ICB})/2]$ \n ($\\mathrm{kg.m^{-2}.s^{-1}}$)",
            fontsize="small",
        )
        ax[i, j].yaxis.get_offset_text().set_position((-0.18, 0))
        ax[i, j].grid()

    i = 2
    ax[i, j].plot(
        s2y(SW_M[n].t[m][mask_BMO_M[n][m]]) / 1e9,
        SW_M[n].mask_dC0dr_TOT_BMO_S2020[m][mask_BMO_M[n][m]],
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel(
            "$\\dfrac{r \in [R_{CMB}, R_{BMO}] \\mid q_b(r) < 0}{R_{BMO} - R_{CMB}}$",
            fontsize="small",
        )
        ax[i, j].yaxis.get_offset_text().set_position((-0.18, 0))
        ax[i, j].grid()
        ax[i, j].set_ylim(-0.1, 1.1)

    i = 3
    ax[i, j].plot(
        s2y(SW_M[n].t[m]) / 1e9,
        SW_M[n].mask_dC0dr_TOT_core[m] * mask_OC,
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel(
            "$\\dfrac{r \in [R_{ICB}, R_{CMB}] \\mid q_c(r) < 0}{R_{CMB} - R_{ICB}}$",
            fontsize="small",
        )
        ax[i, j].grid()
        ax[i, j].set_ylim(-0.1, 1.1)

ax[i, j].set_xlabel("$t$ (Gyr)")
ax[i, j].set_xlim(0, 10)

ax_cbar = fig.add_axes([0.14, -0.02, 0.35, 0.02])

levels = np.linspace(0, 1, len(SW_M[n].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])

cb = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="$M_P/M_{\\oplus}$",
    orientation="horizontal",
)
cb.ax.set_xticks(midpoints)
cb.ax.set_xticklabels(SW_M[n].sw_val.astype(int))

n, j = 3, 1
for m in range(len(SW_CMF[n].sw_val)):
    mask_OC = np.where(SW_CMF[n].L_OC[m] > 0, 1, np.nan)

    mask_core_art = np.ones(len(SW_CMF[n].t[m]), dtype=bool)
    idx = np.argwhere(SW_CMF[n].L_OC[m] == 0).flatten()
    if len(idx) > 0:
        mask_core_art[idx[0] - 1 : idx[0] + 1] = 0

    i = 0
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m][mask_BMO_CMF[n][m] & mask_core_art]) / 1e9,
        SW_CMF[n].dC0dr_TOT_BMO_S2020_MID[m][mask_BMO_CMF[n][m] & mask_core_art],
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_title("$M_P={:.0f}$ ".format(M_CMF[n]) + "$M_{\\oplus}$")
        ax[i, j].yaxis.get_offset_text().set_position((-0.18, 0))
        ax[i, j].grid()

    i = 1
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m])[mask_core_art] / 1e9,
        SW_CMF[n].dC0dr_TOT_core_MID[m][mask_core_art] * mask_OC[mask_core_art],
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].yaxis.get_offset_text().set_position((-0.18, 0))
        ax[i, j].grid()

    i = 2
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m][mask_BMO_CMF[n][m]]) / 1e9,
        SW_CMF[n].mask_dC0dr_TOT_BMO_S2020[m][mask_BMO_CMF[n][m]],
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].yaxis.get_offset_text().set_position((-0.18, 0))
        ax[i, j].grid()
        ax[i, j].set_ylim(-0.1, 1.1)

    i = 3
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m]) / 1e9,
        SW_CMF[n].mask_dC0dr_TOT_core[m] * mask_OC,
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].grid()
        ax[i, j].set_ylim(-0.1, 1.1)

ax[i, j].set_xlabel("$t$ (Gyr)")

ax_cbar = fig.add_axes([0.62, -0.02, 0.35, 0.02])

levels = np.linspace(0, 1, len(SW_CMF[n].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])

cb = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="CMF",
    orientation="horizontal",
)
cb.ax.set_xticks(midpoints)
cb.ax.set_xticklabels(SW_CMF[n].sw_val)

subplots_label(ax)
if save_fig:
    fig.savefig(save_path + "/SI_buoyancy_M_CMF.pdf")

# %% M = {1, 4, 8} & CMF = 0.32
fig, ax = plt.subplots(
    2, 3, figsize=(8, 5), sharex=True, sharey=True, constrained_layout=True
)

n = 1
m_p = np.array([0, 3, 7])

for m in range(len(m_p)):
    mask_OC = np.where(SW_M[n].L_OC[m_p[m]] > 0, 1, np.nan)

    i = 0
    p = ax[i, m].pcolormesh(
        s2y(SW_M[n].t[m_p[m]]) / 1e9,
        np.linspace(0, 1, np.size(SW_M[n].dC0dr_TOT_BMO_S2020[m_p[m]], 1)),
        SW_M[n].dC0dr_TOT_BMO_S2020[m_p[m]].T
        * np.where(mask_BMO_M[n][m_p[m]], 1, np.nan),
        cmap="BrBG_r",
        shading="auto",
        norm=mpl.colors.SymLogNorm(
            linthresh=2e-9,
            vmin=-2e-8,
            vmax=+2e-8,
        ),
        rasterized=True,
    )
    if m == len(m_p) - 1:
        ax_cbar = fig.add_axes([1, 0.56, 0.0125, 0.39])
        cb = fig.colorbar(
            p,
            cax=ax_cbar,
            location="right",
        )
        cb.set_label("$q_{b}$ ($\mathrm{kg.m^{-2}.s^{-1}}$)")

    ax[i, m].set_title("$M_P={:.0f}$ ".format(SW_M[n].sw_val[m_p[m]]) + "$M_{\\oplus}$")
    if m == 0:
        ax[i, m].set_ylabel("$\\dfrac{r-R_{CMB}}{R_{BMO}-R_{CMB}}$")

    i = 1
    p = ax[i, m].pcolormesh(
        s2y(SW_M[n].t[m_p[m]]) / 1e9,
        np.linspace(0, 1, np.size(SW_M[n].dC0dr_TOT_core[m_p[m]], 1)),
        SW_M[n].dC0dr_TOT_core[m_p[m]].T * mask_OC,
        cmap="BrBG_r",
        shading="auto",
        norm=mpl.colors.SymLogNorm(
            linthresh=1e-10,
            vmin=-1.5e-7,
            vmax=+1.5e-7,
        ),
        rasterized=True,
    )
    ax[i, m].contour(
        s2y(SW_M[n].t[m_p[m]]) / 1e9,
        np.linspace(0, 1, np.size(SW_M[n].dC0dr_TOT_core[m_p[m]], 1))[1:],
        SW_M[n].dC0dr_TOT_core[m_p[m]].T[1:, :],
        levels=[0],
        colors="lime",
        linestyles="dashed",
    )
    if m == len(m_p) - 1:
        ax_cbar = fig.add_axes([1, 0.096, 0.0125, 0.39])
        cb = fig.colorbar(
            p,
            cax=ax_cbar,
            location="right",
        )
        cb.set_label("$q_{c}$ ($\mathrm{kg.m^{-2}.s^{-1}}$)")

    if m == 0:
        ax[i, m].set_ylabel("$\\dfrac{r-R_{ICB}}{R_{CMB}-R_{ICB}}$")

    ax[i, m].set_xlabel("$t$ (Gyr)")
    ax[i, m].set_xlim(0, 10)

subplots_label(ax)
if save_fig:
    fig.savefig(save_path + "/SI_buoyancy.pdf")

# %% SI: Entropy budget
# =============================================================================
# Dissipation
fig, ax = plt.subplots(2, 2, figsize=(7, 6), sharex=True, constrained_layout=True)

n, j = 1, 0
for m in range(len(SW_M[n].sw_val)):
    mask_OC = np.where(SW_M[n].L_OC[m] > 0, 1, np.nan)

    mask_core_art = np.ones(len(SW_M[n].t[m]), dtype=bool)
    idx = np.argwhere(SW_M[n].L_OC[m] == 0).flatten()
    if len(idx) > 0:
        mask_core_art[idx[0] - 1 : idx[0] + 1] = 0

    i = 0
    ax[i, j].plot(
        s2y(SW_M[n].t[m][mask_BMO_M[n][m] & mask_core_art]) / 1e9,
        SW_M[n].E_PHI_BMO_S2020[m][mask_BMO_M[n][m] & mask_core_art] / 1e6,
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel("$E_{\Phi,b}$ ($\\mathrm{MW.K^{-1}}$)")
        ax[i, j].set_title("$\\mathrm{CMF}=$" + "${:.2f}$".format(CMF_M[n]))
        ax[i, j].set_yscale("symlog", linthresh=1e1)
        ax[i, j].grid()

    i = 1
    ax[i, j].plot(
        s2y(SW_M[n].t[m]) / 1e9,
        SW_M[n].E_PHI_core_S2020[m] * mask_OC / 1e6,
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel("$E_{\Phi,c}$ ($\\mathrm{MW.K^{-1}}$)")
        ax[i, j].set_yscale("symlog", linthresh=1e1)
        ax[i, j].grid()

ax[i, j].set_xlabel("$t$ (Gyr)")
ax[i, j].set_xlim(0, 10)

ax_cbar = fig.add_axes([0.11, -0.025, 0.38, 0.025])

levels = np.linspace(0, 1, len(SW_M[n].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])

cb = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="$M_P/M_{\\oplus}$",
    orientation="horizontal",
)
cb.ax.set_xticks(midpoints)
cb.ax.set_xticklabels(SW_M[n].sw_val.astype(int))

n, j = 3, 1
for m in range(len(SW_CMF[n].sw_val)):
    mask_OC = np.where(SW_CMF[n].L_OC[m] > 0, 1, np.nan)

    mask_core_art = np.ones(len(SW_CMF[n].t[m]), dtype=bool)
    idx = np.argwhere(SW_CMF[n].L_OC[m] == 0).flatten()
    if len(idx) > 0:
        mask_core_art[idx[0] - 1 : idx[0] + 1] = 0

    i = 0
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m][mask_BMO_CMF[n][m] & mask_core_art]) / 1e9,
        SW_CMF[n].E_PHI_BMO_S2020[m][mask_BMO_CMF[n][m] & mask_core_art] / 1e6,
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_title("$M_P={:.0f}$ ".format(M_CMF[n]) + "$M_{\\oplus}$")
        ax[i, j].set_yscale("symlog", linthresh=1e1)
        ax[i, j].grid()

    i = 1
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m]) / 1e9,
        SW_CMF[n].E_PHI_core_S2020[m] * mask_OC / 1e6,
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_yscale("symlog", linthresh=1e1)
        ax[i, j].grid()

ax[i, j].set_xlabel("$t$ (Gyr)")

ax_cbar = fig.add_axes([0.59, -0.025, 0.38, 0.025])

levels = np.linspace(0, 1, len(SW_CMF[n].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])

cb = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="CMF",
    orientation="horizontal",
)
cb.ax.set_xticks(midpoints)
cb.ax.set_xticklabels(SW_CMF[n].sw_val)

subplots_label(ax)
if save_fig:
    fig.savefig(save_path + "/SI_entropy_M_CMF.pdf")

# %% M = {1, 4, 8} & CMF = 0.32
fig, ax = plt.subplots(2, 3, figsize=(8, 5), sharex=True)

n = 1
m_p = np.array([0, 3, 7])

for m in range(len(m_p)):
    mask_OC = np.where(SW_M[n].L_OC[m_p[m]] > 0, 1, np.nan)

    mask_core_art = np.ones(len(SW_M[n].t[m_p[m]]), dtype=bool)
    idx = np.argwhere(SW_M[n].L_OC[m_p[m]] == 0).flatten()
    if len(idx) > 0:
        mask_core_art[idx[0] - 1 : idx[0] + 1] = 0

    i = 0
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]])[mask_BMO_M[n][m_p[m]]] / 1e9,
        SW_M[n].E_R_BMO_S2020[m_p[m]][mask_BMO_M[n][m_p[m]]] / 1e6,
        color=tab20(1),
        label="$E_{R,b}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]])[mask_BMO_M[n][m_p[m]]] / 1e9,
        SW_M[n].E_S_BMO_S2020[m_p[m]][mask_BMO_M[n][m_p[m]]] / 1e6,
        color=tab20(3),
        label="$E_{S,b}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]])[mask_BMO_M[n][m_p[m]]] / 1e9,
        SW_M[n].E_G_BMO_S2020[m_p[m]][mask_BMO_M[n][m_p[m]]] / 1e6,
        color=tab20(5),
        label="$E_{G,b}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]])[mask_BMO_M[n][m_p[m]]] / 1e9,
        SW_M[n].E_L_BMO_S2020[m_p[m]][mask_BMO_M[n][m_p[m]]] / 1e6,
        color=tab20(7),
        label="$E_{L,b}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]])[mask_BMO_M[n][m_p[m]]] / 1e9,
        SW_M[n].E_K_BMO_S2020[m_p[m]][mask_BMO_M[n][m_p[m]]] / 1e6,
        color=tab20(13),
        label="$E_{K,b}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]])[mask_BMO_M[n][m_p[m]]] / 1e9,
        SW_M[n].E_Alpha_BMO_S2020[m_p[m]][mask_BMO_M[n][m_p[m]]] / 1e6,
        color=tab20(15),
        label="$E_{\\alpha,b}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]])[mask_BMO_M[n][m_p[m]] & mask_core_art] / 1e9,
        SW_M[n].E_CMB_S2020[m_p[m]][mask_BMO_M[n][m_p[m]] & mask_core_art] / 1e6,
        color=tab20c(0),
        label="$E_{CMB}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]])[mask_BMO_M[n][m_p[m]] & mask_core_art] / 1e9,
        SW_M[n].E_PHI_BMO_S2020[m_p[m]][mask_BMO_M[n][m_p[m]] & mask_core_art] / 1e6,
        "k--",
        label="$E_{\\Phi,b}$",
    )

    ax[i, m].set_title("$M_P={:.0f}$ ".format(SW_M[n].sw_val[m_p[m]]) + "$M_{\\oplus}$")
    if m == 0:
        ax[i, m].set_ylabel("$E$ ($\\mathrm{MW.K^{-1}}$)")
        ax[i, m].legend(loc="upper right", fontsize="x-small")
    ax[i, m].grid()

    i = 1
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]]) / 1e9,
        SW_M[n].E_R_core_S2020[m_p[m]] * mask_OC / 1e6,
        color=tab20(1),
        label="$E_{R,c}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]]) / 1e9,
        SW_M[n].E_S_core_S2020[m_p[m]] * mask_OC / 1e6,
        color=tab20(3),
        label="$E_{S,c}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]]) / 1e9,
        SW_M[n].E_G_core_S2020[m_p[m]] * mask_OC / 1e6,
        color=tab20(5),
        label="$E_{G,c}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]]) / 1e9,
        SW_M[n].E_L_core_S2020[m_p[m]] * mask_OC / 1e6,
        color=tab20(7),
        label="$E_{L,c}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]]) / 1e9,
        SW_M[n].E_K_core_S2020[m_p[m]] * mask_OC / 1e6,
        color=tab20(13),
        label="$E_{K,c}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]]) / 1e9,
        SW_M[n].E_Alpha_core_S2020[m_p[m]] * mask_OC / 1e6,
        color=tab20(15),
        label="$E_{\\alpha,c}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]]) / 1e9,
        SW_M[n].E_ICB_S2020[m_p[m]] * mask_OC / 1e6,
        color=tab20c(16),
        label="$E_{ICB}$",
    )
    ax[i, m].plot(
        s2y(SW_M[n].t[m_p[m]]) / 1e9,
        SW_M[n].E_PHI_core_S2020[m_p[m]] * mask_OC / 1e6,
        "k--",
        label="$E_{\\Phi,c}$",
    )

    if m == 0:
        ax[i, m].set_ylabel("$E$ ($\\mathrm{MW.K^{-1}}$)")
        ax[i, m].legend(loc="upper right", fontsize="x-small")
    ax[i, m].grid()

    ax[i, m].set_xlabel("$t$ (Gyr)")
    ax[i, m].set_xlim(0, 10)

subplots_label(ax)
if save_fig:
    fig.savefig(save_path + "/SI_entropy.pdf")

# %% SI: Convection
# =============================================================================
# Convective power
fig, ax = plt.subplots(2, 2, figsize=(7, 6), sharex=True, constrained_layout=True)

n, j = 1, 0
for m in range(len(SW_M[n].sw_val)):
    mask_OC = np.where(SW_M[n].L_OC[m] > 0, 1, np.nan)

    mask_core_art = np.ones(len(SW_M[n].t[m]), dtype=bool)
    idx = np.argwhere(SW_M[n].L_OC[m] == 0).flatten()
    if len(idx) > 0:
        mask_core_art[idx[0] - 1 : idx[0] + 1] = 0

    i = 0
    phi_BMO_S2020 = (
        SW_M[n].p_S_BMO_S2020[m]
        * SW_M[n].M_BMO[m]
        * SW_M[n].L_BMO[m] ** 2
        * SW_M[n].Omega[m] ** 3
    )
    ax[i, j].plot(
        s2y(SW_M[n].t[m][mask_BMO_M[n][m] & mask_core_art]) / 1e9,
        phi_BMO_S2020[mask_BMO_M[n][m] & mask_core_art] / 1e12,
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel("$\Phi_b$ ($\\mathrm{TW}$)")
        ax[i, j].set_title("$\\mathrm{CMF}=$" + "${:.2f}$".format(CMF_M[n]))
        ax[i, j].set_yscale("log")
        ax[i, j].grid()

    i = 1
    phi_core_S2020 = (
        SW_M[n].p_S_core_S2020[m]
        * SW_M[n].M_OC[m]
        * SW_M[n].L_OC[m] ** 2
        * SW_M[n].Omega[m] ** 3
    )
    ax[i, j].plot(
        s2y(SW_M[n].t[m]) / 1e9,
        phi_core_S2020 * mask_OC / 1e12,
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel("$\Phi_c$ ($\\mathrm{TW}$)")
        ax[i, j].set_yscale("log")
        ax[i, j].grid()

ax[i, j].set_xlabel("$t$ (Gyr)")
ax[i, j].set_xlim(0, 10)

ax_cbar = fig.add_axes([0.11, -0.025, 0.38, 0.025])

levels = np.linspace(0, 1, len(SW_M[n].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])

cb = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="$M_P/M_{\\oplus}$",
    orientation="horizontal",
)
cb.ax.set_xticks(midpoints)
cb.ax.set_xticklabels(SW_M[n].sw_val.astype(int))

n, j = 3, 1
for m in range(len(SW_CMF[n].sw_val)):
    mask_OC = np.where(SW_CMF[n].L_OC[m] > 0, 1, np.nan)

    mask_core_art = np.ones(len(SW_CMF[n].t[m]), dtype=bool)
    idx = np.argwhere(SW_CMF[n].L_OC[m] == 0).flatten()
    if len(idx) > 0:
        mask_core_art[idx[0] - 1 : idx[0] + 1] = 0

    i = 0
    phi_BMO_S2020 = (
        SW_CMF[n].p_S_BMO_S2020[m]
        * SW_CMF[n].M_BMO[m]
        * SW_CMF[n].L_BMO[m] ** 2
        * SW_CMF[n].Omega[m] ** 3
    )
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m][mask_BMO_CMF[n][m] & mask_core_art]) / 1e9,
        phi_BMO_S2020[mask_BMO_CMF[n][m] & mask_core_art] / 1e12,
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_title("$M_P={:.0f}$ ".format(M_CMF[n]) + "$M_{\\oplus}$")
        ax[i, j].set_yscale("log")
        ax[i, j].grid()

    i = 1
    phi_core_S2020 = (
        SW_CMF[n].p_S_core_S2020[m]
        * SW_CMF[n].M_OC[m]
        * SW_CMF[n].L_OC[m] ** 2
        * SW_CMF[n].Omega[m] ** 3
    )
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m]) / 1e9,
        phi_core_S2020 * mask_OC / 1e12,
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_yscale("log")
        ax[i, j].grid()

ax[i, j].set_xlabel("$t$ (Gyr)")

ax_cbar = fig.add_axes([0.59, -0.025, 0.38, 0.025])

levels = np.linspace(0, 1, len(SW_CMF[n].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])

cb = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="CMF",
    orientation="horizontal",
)
cb.ax.set_xticks(midpoints)
cb.ax.set_xticklabels(SW_CMF[n].sw_val)

subplots_label(ax)
if save_fig:
    fig.savefig(save_path + "/SI_convective_power.pdf")

# %% Convective velocity
fig, ax = plt.subplots(2, 2, figsize=(7, 6), sharex=True, constrained_layout=True)

n, j = 1, 0
for m in range(len(SW_M[n].sw_val)):
    mask_OC = np.where(SW_M[n].L_OC[m] > 0, 1, np.nan)

    mask_core_art = np.ones(len(SW_M[n].t[m]), dtype=bool)
    idx = np.argwhere(SW_M[n].L_OC[m] == 0).flatten()
    if len(idx) > 0:
        mask_core_art[idx[0] - 1 : idx[0] + 1] = 0

    i = 0
    ax[i, j].plot(
        s2y(SW_M[n].t[m][mask_BMO_M[n][m] & mask_core_art]) / 1e9,
        SW_M[n].U_S_BMO_S2020[m][mask_BMO_M[n][m] & mask_core_art],
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel("$U_b$ ($\\mathrm{m.s^{-1}}$)")
        ax[i, j].set_title("$\\mathrm{CMF}=$" + "${:.2f}$".format(CMF_M[n]))
        ax[i, j].grid()

    i = 1
    ax[i, j].plot(
        s2y(SW_M[n].t[m]) / 1e9,
        SW_M[n].U_S_core_S2020[m] * mask_OC,
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel("$U_c$ ($\\mathrm{m.s^{-1}}$)")
        ax[i, j].grid()

ax[i, j].set_xlabel("$t$ (Gyr)")
ax[i, j].set_xlim(0, 10)

ax_cbar = fig.add_axes([0.11, -0.025, 0.38, 0.025])

levels = np.linspace(0, 1, len(SW_M[n].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])

cb = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="$M_P/M_{\\oplus}$",
    orientation="horizontal",
)
cb.ax.set_xticks(midpoints)
cb.ax.set_xticklabels(SW_M[n].sw_val.astype(int))

n, j = 3, 1
for m in range(len(SW_CMF[n].sw_val)):
    mask_OC = np.where(SW_CMF[n].L_OC[m] > 0, 1, np.nan)

    mask_core_art = np.ones(len(SW_CMF[n].t[m]), dtype=bool)
    idx = np.argwhere(SW_CMF[n].L_OC[m] == 0).flatten()
    if len(idx) > 0:
        mask_core_art[idx[0] - 1 : idx[0] + 1] = 0

    i = 0
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m][mask_BMO_CMF[n][m] & mask_core_art]) / 1e9,
        SW_CMF[n].U_S_BMO_S2020[m][mask_BMO_CMF[n][m] & mask_core_art],
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_title("$M_P={:.0f}$ ".format(M_CMF[n]) + "$M_{\\oplus}$")
        ax[i, j].grid()

    i = 1
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m]) / 1e9,
        SW_CMF[n].U_S_core_S2020[m] * mask_OC,
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].grid()

ax[i, j].set_xlabel("$t$ (Gyr)")

ax_cbar = fig.add_axes([0.59, -0.025, 0.38, 0.025])

levels = np.linspace(0, 1, len(SW_CMF[n].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])

cb = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="CMF",
    orientation="horizontal",
)
cb.ax.set_xticks(midpoints)
cb.ax.set_xticklabels(SW_CMF[n].sw_val)

subplots_label(ax)
if save_fig:
    fig.savefig(save_path + "/SI_convective_velocity.pdf")

# %% SI: Magnetic field
# =============================================================================
# BMO
fig, ax = plt.subplots(3, 2, figsize=(7, 7), sharex=True, constrained_layout=True)

n, j = 1, 0
for m in range(len(SW_M[n].sw_val)):
    mask_core_art = np.ones(len(SW_M[n].t[m]), dtype=bool)
    idx = np.argwhere(SW_M[n].L_OC[m] == 0).flatten()
    if len(idx) > 0:
        mask_core_art[idx[0] - 1 : idx[0] + 1] = 0

    i = 0
    ax[i, j].plot(
        s2y(SW_M[n].t[m])[mask_BMO_M[n][m] & mask_core_art] / 1e9,
        SW_M[n].Rm_S_BMO_S2020[m][mask_BMO_M[n][m] & mask_core_art],
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel("$R_{m_b}$")
        ax[i, j].axhline(y=SW_M[n].param[m].Rm_crit_BMO, linestyle="--", color="r")
        ax[i, j].text(9.9, 45, "$R_m=40$", ha="right", va="bottom", color="r")
        ax[i, j].set_title("$\\mathrm{CMF}=$" + "${:.2f}$".format(CMF_M[n]))
        ax[i, j].set_yscale("log")
        ax[i, j].set_ylim([1e-1, 2e3])
        ax[i, j].grid()

    i = 1
    ax[i, j].plot(
        s2y(SW_M[n].t[m][mask_BMO_M[n][m] & mask_core_art]) / 1e9,
        SW_M[n].B_S_BMO_S2020[m][mask_BMO_M[n][m] & mask_core_art]
        * np.where(
            SW_M[n].Rm_S_BMO_S2020[m] > SW_M[n].param[m].Rm_crit_BMO,
            1,
            np.nan,
        )[mask_BMO_M[n][m] & mask_core_art]
        * 1e3,
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel("$B_b$ (mT)")
        ax[i, j].grid()

    i = 2
    ax[i, j].plot(
        s2y(SW_M[n].t[m])[mask_BMO_M[n][m] & mask_core_art] / 1e9,
        SW_M[n].BS_S_BMO_cst_S2020[m][mask_BMO_M[n][m] & mask_core_art]
        * np.where(
            SW_M[n].Rm_S_BMO_S2020[m] > SW_M[n].param[m].Rm_crit_BMO,
            1,
            np.nan,
        )[mask_BMO_M[n][m] & mask_core_art]
        * 1e6,
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel("$B_{P,b}$ ($\mu$T)")
        ax[i, j].grid()

ax[i, j].set_xlabel("$t$ (Gyr)")
ax[i, j].set_xlim(0, 10)

ax_cbar = fig.add_axes([0.11, -0.025, 0.38, 0.025])

levels = np.linspace(0, 1, len(SW_M[n].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])

cb = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="$M_P/M_{\\oplus}$",
    orientation="horizontal",
)
cb.ax.set_xticks(midpoints)
cb.ax.set_xticklabels(SW_M[n].sw_val.astype(int))

n, j = 3, 1
for m in range(len(SW_CMF[n].sw_val)):
    mask_core_art = np.ones(len(SW_CMF[n].t[m]), dtype=bool)
    idx = np.argwhere(SW_CMF[n].L_OC[m] == 0).flatten()
    if len(idx) > 0:
        mask_core_art[idx[0] - 1 : idx[0] + 1] = 0

    i = 0
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m])[mask_BMO_CMF[n][m] & mask_core_art] / 1e9,
        SW_CMF[n].Rm_S_BMO_S2020[m][mask_BMO_CMF[n][m] & mask_core_art],
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].axhline(y=SW_CMF[n].param[m].Rm_crit_BMO, linestyle="--", color="r")
        ax[i, j].text(9.9, 45, "$R_m=40$", ha="right", va="bottom", color="r")
        ax[i, j].set_title("$M_P={:.0f}$ ".format(M_CMF[n]) + "$M_{\\oplus}$")
        ax[i, j].set_yscale("log")
        ax[i, j].set_ylim([1e-1, 1e3])
        ax[i, j].grid()

    i = 1
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m][mask_BMO_CMF[n][m] & mask_core_art]) / 1e9,
        SW_CMF[n].B_S_BMO_S2020[m][mask_BMO_CMF[n][m] & mask_core_art]
        * np.where(
            SW_CMF[n].Rm_S_BMO_S2020[m] > SW_CMF[n].param[m].Rm_crit_BMO,
            1,
            np.nan,
        )[mask_BMO_CMF[n][m] & mask_core_art]
        * 1e3,
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].grid()

    i = 2
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m])[mask_BMO_CMF[n][m] & mask_core_art] / 1e9,
        SW_CMF[n].BS_S_BMO_cst_S2020[m][mask_BMO_CMF[n][m] & mask_core_art]
        * np.where(
            SW_CMF[n].Rm_S_BMO_S2020[m] > SW_CMF[n].param[m].Rm_crit_BMO,
            1,
            np.nan,
        )[mask_BMO_CMF[n][m] & mask_core_art]
        * 1e6,
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].grid()

ax[i, j].set_xlabel("$t$ (Gyr)")

ax_cbar = fig.add_axes([0.59, -0.025, 0.38, 0.025])

levels = np.linspace(0, 1, len(SW_CMF[n].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])

cb = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="CMF",
    orientation="horizontal",
)
cb.ax.set_xticks(midpoints)
cb.ax.set_xticklabels(SW_CMF[n].sw_val)

subplots_label(ax)
if save_fig:
    fig.savefig(save_path + "/SI_magnetic_BMO.pdf")

# %% Core
fig, ax = plt.subplots(3, 2, figsize=(7, 7), sharex=True, constrained_layout=True)

n, j = 1, 0
for m in range(len(SW_M[n].sw_val)):
    mask_OC = np.where(SW_M[n].L_OC[m] > 0, 1, np.nan)

    i = 0
    ax[i, j].plot(
        s2y(SW_M[n].t[m]) / 1e9,
        SW_M[n].Rm_S_core_S2020[m],
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel("$R_{m_c}$")
        ax[i, j].axhline(y=SW_M[n].param[m].Rm_crit_core, linestyle="--", color="r")
        ax[i, j].text(9.9, 45, "$R_m=40$", ha="right", va="bottom", color="r")
        ax[i, j].set_title("$\\mathrm{CMF}=$" + "${:.2f}$".format(CMF_M[n]))
        ax[i, j].set_yscale("log")
        ax[i, j].set_ylim([1e1, 6e3])
        ax[i, j].grid()

    i = 1
    ax[i, j].plot(
        s2y(SW_M[n].t[m]) / 1e9,
        SW_M[n].B_S_core_S2020[m]
        * np.where(
            SW_M[n].Rm_S_core_S2020[m] > SW_M[n].param[m].Rm_crit_core,
            1,
            np.nan,
        )
        * 1e3,
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel("$B_c$ (mT)")
        ax[i, j].grid()

    i = 2
    ax[i, j].plot(
        s2y(SW_M[n].t[m]) / 1e9,
        SW_M[n].BS_S_core_cst_S2020[m]
        * np.where(
            SW_M[n].Rm_S_core_S2020[m] > SW_M[n].param[m].Rm_crit_core,
            1,
            np.nan,
        )
        * 1e6,
        color=viridis(len(SW_M[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].set_ylabel("$B_{P,c}$ ($\mu$T)")
        ax[i, j].grid()

ax[i, j].set_xlabel("$t$ (Gyr)")
ax[i, j].set_xlim(0, 10)

ax_cbar = fig.add_axes([0.11, -0.025, 0.38, 0.025])

levels = np.linspace(0, 1, len(SW_M[n].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])

cb = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="$M_P/M_{\\oplus}$",
    orientation="horizontal",
)
cb.ax.set_xticks(midpoints)
cb.ax.set_xticklabels(SW_M[n].sw_val.astype(int))

n, j = 3, 1
for m in range(len(SW_CMF[n].sw_val)):
    mask_OC = np.where(SW_CMF[n].L_OC[m] > 0, 1, np.nan)

    i = 0
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m]) / 1e9,
        SW_CMF[n].Rm_S_core_S2020[m],
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].axhline(y=SW_CMF[n].param[m].Rm_crit_core, linestyle="--", color="r")
        ax[i, j].text(9.9, 45, "$R_m=40$", ha="right", va="bottom", color="r")
        ax[i, j].set_title("$M_P={:.0f}$ ".format(M_CMF[n]) + "$M_{\\oplus}$")
        ax[i, j].set_yscale("log")
        ax[i, j].set_ylim([1e1, 5e3])
        ax[i, j].grid()

    i = 1
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m]) / 1e9,
        SW_CMF[n].B_S_core_S2020[m]
        * np.where(
            SW_CMF[n].Rm_S_core_S2020[m] > SW_CMF[n].param[m].Rm_crit_core,
            1,
            np.nan,
        )
        * 1e3,
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].grid()

    i = 2
    ax[i, j].plot(
        s2y(SW_CMF[n].t[m]) / 1e9,
        SW_CMF[n].BS_S_core_cst_S2020[m]
        * np.where(
            SW_CMF[n].Rm_S_core_S2020[m] > SW_CMF[n].param[m].Rm_crit_core,
            1,
            np.nan,
        )
        * 1e6,
        color=viridis(len(SW_CMF[n].sw_val))[m],
    )

    if m == 0:
        ax[i, j].grid()

ax[i, j].set_xlabel("$t$ (Gyr)")

ax_cbar = fig.add_axes([0.59, -0.025, 0.38, 0.025])

levels = np.linspace(0, 1, len(SW_CMF[n].sw_val) + 1)
midpoints = 0.5 * (levels[:-1] + levels[1:])

cb = fig.colorbar(
    mpl.cm.ScalarMappable(
        norm=mpl.colors.BoundaryNorm(levels, mpl.cm.viridis.N),
        cmap=mpl.cm.viridis,
    ),
    cax=ax_cbar,
    label="CMF",
    orientation="horizontal",
)
cb.ax.set_xticks(midpoints)
cb.ax.set_xticklabels(SW_CMF[n].sw_val)

subplots_label(ax)
if save_fig:
    fig.savefig(save_path + "/SI_magnetic_core.pdf")

# %% SI: Sensitivity (n_mu)
# =============================================================================
# Load .pkl
with open(data_path + "/sw_n_mu.pkl", "rb") as f:
    SW = pkl.load(f)

# Pre-processing
t_idx = np.argwhere(~np.isnan(SW.t)[:, 0]).flatten()[0]
t_m, sw_val_m = np.meshgrid(SW.t[t_idx], SW.sw_val)

BMO_idx = np.argmin(
    np.abs(np.where(~np.isnan(SW.T_BMO), SW.T_CMB - SW.T_BMO, 0) - 1),
    axis=1,
)
t_BMO = SW.t[t_idx][BMO_idx]

mask_BMO = np.zeros((len(SW.sw_val), len(SW.t[t_idx])))
for i in range(len(SW.sw_val)):
    mask_BMO[i] = np.where(SW.t[i] < t_BMO[i], 1, np.nan)

dR_BMOdt = np.gradient(SW.R_BMO, SW.t[t_idx], axis=1)
filt = np.ones_like(dR_BMOdt)
for i in range(len(SW.sw_val)):
    if np.any(dR_BMOdt[i] > 0):
        filt[i] = np.nan * np.ones_like(dR_BMOdt[i])

# Plot
fig, ax = plt.subplots(3, 2, figsize=(8, 9), sharex=True, sharey=True)
i, j = 0, 0
p = ax[i, j].pcolormesh(
    s2y(SW.t[t_idx]) / 1e9,
    SW.sw_val,
    SW.E_PHI_BMO_S2020 * mask_BMO / 1e6 * filt,
    cmap="RdBu",
    shading="auto",
    norm=mpl.colors.SymLogNorm(
        linthresh=2e4,
        vmin=-np.nanmax(np.abs(SW.E_PHI_BMO_S2020 * mask_BMO / 1e6 * filt)),
        vmax=+np.nanmax(np.abs(SW.E_PHI_BMO_S2020 * mask_BMO / 1e6 * filt)),
    ),
    rasterized=True,
)
ax[i, j].contour(
    s2y(t_m) / 1e9,
    sw_val_m,
    SW.E_PHI_BMO_S2020 * mask_BMO / 1e6 * filt,
    levels=[0],
    colors="lime",
    linestyles="dashed",
)
ax[i, j].axhline(y=psi_eta, linestyle="--", color="magenta")
ax[i, j].text(
    s2y(SW.t[0][-1]) / 1e9,
    psi_eta,
    "Nominal",
    ha="right",
    va="bottom",
    color="magenta",
)
fig.colorbar(
    p, ax=ax[i, j], label="$E_{\Phi,b}$ ($\mathrm{MW.K^{-1}}$)", location="top"
)
ax[i, j].set_ylabel("$n_\mu$")
ax[i, j].set_ylim(
    [
        np.min(SW.sw_val[~np.isnan((SW.t * filt)[:, 0])]),
        np.max(SW.sw_val[~np.isnan((SW.t * filt)[:, 0])]),
    ]
)

i, j = 0, 1
mask_core = np.where(SW.L_OC > 0, 1, np.nan)
p = ax[i, j].pcolormesh(
    s2y(SW.t[t_idx]) / 1e9,
    SW.sw_val,
    SW.E_PHI_core_S2020 * mask_core / 1e6 * filt,
    cmap="RdBu",
    shading="auto",
    norm=mpl.colors.SymLogNorm(
        linthresh=2e3,
        vmin=-np.nanmax(np.abs(SW.E_PHI_core_S2020 * mask_core / 1e6 * filt)),
        vmax=+np.nanmax(np.abs(SW.E_PHI_core_S2020 * mask_core / 1e6 * filt)),
    ),
    rasterized=True,
)
ax[i, j].contour(
    s2y(t_m) / 1e9,
    sw_val_m,
    SW.E_PHI_core_S2020 * mask_core / 1e6 * filt,
    levels=[0],
    colors="lime",
    linestyles="dashed",
)
ax[i, j].axhline(y=psi_eta, linestyle="--", color="magenta")
ax[i, j].text(
    s2y(SW.t[0][-1]) / 1e9,
    psi_eta,
    "Nominal",
    ha="right",
    va="bottom",
    color="magenta",
)
fig.colorbar(
    p, ax=ax[i, j], label="$E_{\Phi,c}$ ($\mathrm{MW.K^{-1}}$)", location="top"
)
ax[i, j].set_ylim(
    [
        np.min(SW.sw_val[~np.isnan((SW.t * filt)[:, 0])]),
        np.max(SW.sw_val[~np.isnan((SW.t * filt)[:, 0])]),
    ]
)

ax_inset_b = fig.add_axes([0.75, 0.73, 0.21, 0.12])
ax_inset_b.plot(
    SW.sw_val,
    SW.k_core_min,
    "k",
)
ax_inset_b.set_xlabel("$n_\mu$", fontsize="small", labelpad=0)
ax_inset_b.set_ylabel(
    "$k_{c,\\mathrm{max}}$ ($\\mathrm{W.m^{-1}.K^{-1}}$)", fontsize="small"
)
ax_inset_b.set_yscale("log")
ax_inset_b.set_xlim(
    [
        np.min(SW.sw_val[~np.isnan((SW.t * filt)[:, 0])]),
        np.max(SW.sw_val[~np.isnan((SW.t * filt)[:, 0])]),
    ]
)
ax_inset_b.grid()
ax_inset_b.tick_params(axis="both", which="major", labelsize="small")

i, j = 1, 0
p = ax[i, j].pcolormesh(
    s2y(SW.t[t_idx]) / 1e9,
    SW.sw_val,
    SW.Rm_S_BMO_S2020 * mask_BMO * filt,
    cmap="magma_r",
    shading="auto",
    rasterized=True,
    vmin=0,
)
ax[i, j].contour(
    s2y(t_m) / 1e9,
    sw_val_m,
    SW.Rm_S_BMO_S2020 * mask_BMO * filt,
    levels=[SW.param[0].Rm_crit_BMO],
    colors="lime",
    linestyles="dashed",
)
ax[i, j].axhline(y=psi_eta, linestyle="--", color="magenta")
ax[i, j].text(
    s2y(SW.t[0][-1]) / 1e9,
    psi_eta,
    "Nominal",
    ha="right",
    va="bottom",
    color="magenta",
)
fig.colorbar(p, ax=ax[i, j], label="$R_{m_b}$", location="top")
ax[i, j].set_ylabel("$n_\mu$")
ax[i, j].set_ylim(
    [
        np.min(SW.sw_val[~np.isnan((SW.t * filt)[:, 0])]),
        np.max(SW.sw_val[~np.isnan((SW.t * filt)[:, 0])]),
    ]
)

ax_inset_c = fig.add_axes([0.285, 0.415, 0.21, 0.12])
ax_inset_c.plot(
    SW.sw_val,
    SW.sigma_BMO_min,
    "k",
)
ax_inset_c.set_xlabel("$n_\mu$", fontsize="small", labelpad=0)
ax_inset_c.set_ylabel(
    "$\\sigma_{b,\\mathrm{min}}$ ($\\mathrm{S.m^{-1}}$)", fontsize="small"
)
ax_inset_c.set_xlim(
    [
        np.min(SW.sw_val[~np.isnan((SW.t * filt)[:, 0])]),
        np.max(SW.sw_val[~np.isnan((SW.t * filt)[:, 0])]),
    ]
)
ax_inset_c.grid()
ax_inset_c.tick_params(axis="both", which="major", labelsize="small")

i, j = 1, 1
p = ax[i, j].pcolormesh(
    s2y(SW.t[t_idx]) / 1e9,
    SW.sw_val,
    SW.Rm_S_core_S2020 * filt,
    cmap="magma_r",
    shading="auto",
    rasterized=True,
    vmin=0,
)
ax[i, j].contour(
    s2y(t_m) / 1e9,
    sw_val_m,
    SW.Rm_S_core_S2020 * filt,
    levels=[SW.param[0].Rm_crit_core],
    colors="lime",
    linestyles="dashed",
)
ax[i, j].axhline(y=psi_eta, linestyle="--", color="magenta")
ax[i, j].text(
    s2y(SW.t[0][-1]) / 1e9,
    psi_eta,
    "Nominal",
    ha="right",
    va="bottom",
    color="magenta",
)
fig.colorbar(p, ax=ax[i, j], label="$R_{m_c}$", location="top")
ax[i, j].set_ylim(
    [
        np.min(SW.sw_val[~np.isnan((SW.t * filt)[:, 0])]),
        np.max(SW.sw_val[~np.isnan((SW.t * filt)[:, 0])]),
    ]
)

i, j = 2, 0
p = ax[i, j].pcolormesh(
    s2y(SW.t[t_idx]) / 1e9,
    SW.sw_val,
    SW.BS_S_BMO_cst_S2020
    * np.where(SW.Rm_S_BMO_S2020 > SW.param[0].Rm_crit_BMO, 1, np.nan)
    * 1e6
    * filt,
    cmap="cividis_r",
    shading="auto",
    rasterized=True,
    vmin=0,
)
ax[i, j].axhline(y=psi_eta, linestyle="--", color="magenta")
ax[i, j].text(
    s2y(SW.t[0][-1]) / 1e9,
    psi_eta,
    "Nominal",
    ha="right",
    va="bottom",
    color="magenta",
)
fig.colorbar(p, ax=ax[i, j], label="$B_{P,b}$ ($\mu\mathrm{T}$)", location="top")
ax[i, j].set_xlabel("$t$ ($\mathrm{Gyr}$)")
ax[i, j].set_ylabel("$n_\mu$")
ax[i, j].set_ylim(
    [
        np.min(SW.sw_val[~np.isnan((SW.t * filt)[:, 0])]),
        np.max(SW.sw_val[~np.isnan((SW.t * filt)[:, 0])]),
    ]
)

i, j = 2, 1
p = ax[i, j].pcolormesh(
    s2y(SW.t[t_idx]) / 1e9,
    SW.sw_val,
    SW.BS_S_core_cst_S2020
    * np.where(SW.Rm_S_core_S2020 > SW.param[0].Rm_crit_core, 1, np.nan)
    * 1e6
    * filt,
    cmap="cividis_r",
    shading="auto",
    rasterized=True,
    vmin=0,
)
ax[i, j].axhline(y=psi_eta, linestyle="--", color="magenta")
ax[i, j].text(
    s2y(SW.t[0][-1]) / 1e9,
    psi_eta,
    "Nominal",
    ha="right",
    va="bottom",
    color="magenta",
)
fig.colorbar(p, ax=ax[i, j], label="$B_{P,c}$ ($\mu\mathrm{T}$)", location="top")
ax[i, j].set_xlabel("$t$ ($\mathrm{Gyr}$)")
ax[i, j].set_ylim(
    [
        np.min(SW.sw_val[~np.isnan((SW.t * filt)[:, 0])]),
        np.max(SW.sw_val[~np.isnan((SW.t * filt)[:, 0])]),
    ]
)

subplots_label(ax, colorbar=True)
if save_fig:
    fig.savefig(save_path + "/SI_sensitivity_psi_eta.pdf")

# %% SI: Sensitivity (m_mu)
# =============================================================================
# Load .pkl
with open(data_path + "/sw_m_mu.pkl", "rb") as f:
    SW = pkl.load(f)

# Pre-processing
t_idx = np.argwhere(~np.isnan(SW.t)[:, 0]).flatten()[0]
t_m, sw_val_m = np.meshgrid(SW.t[t_idx], SW.sw_val)

BMO_idx = np.argmin(
    np.abs(np.where(~np.isnan(SW.T_BMO), SW.T_CMB - SW.T_BMO, 0) - 1),
    axis=1,
)
t_BMO = SW.t[t_idx][BMO_idx]

mask_BMO = np.zeros((len(SW.sw_val), len(SW.t[t_idx])))
for i in range(len(SW.sw_val)):
    mask_BMO[i] = np.where(SW.t[i] < t_BMO[i], 1, np.nan)

dR_BMOdt = np.gradient(SW.R_BMO, SW.t[t_idx], axis=1)
filt = np.ones_like(dR_BMOdt)
for i in range(len(SW.sw_val)):
    if np.any(dR_BMOdt[i] > 0):
        filt[i] = np.nan * np.ones_like(dR_BMOdt[i])

# Plot
fig, ax = plt.subplots(3, 2, figsize=(8, 9), sharex=True, sharey=True)
i, j = 0, 0
p = ax[i, j].pcolormesh(
    s2y(SW.t[t_idx]) / 1e9,
    SW.sw_val,
    SW.E_PHI_BMO_S2020 * mask_BMO / 1e6 * filt,
    cmap="RdBu",
    shading="auto",
    norm=mpl.colors.SymLogNorm(
        linthresh=2e4,
        vmin=-np.nanmax(np.abs(SW.E_PHI_BMO_S2020 * mask_BMO / 1e6 * filt)),
        vmax=+np.nanmax(np.abs(SW.E_PHI_BMO_S2020 * mask_BMO / 1e6 * filt)),
    ),
    rasterized=True,
)
ax[i, j].contour(
    s2y(t_m) / 1e9,
    sw_val_m,
    SW.E_PHI_BMO_S2020 * mask_BMO / 1e6 * filt,
    levels=[0],
    colors="lime",
    linestyles="dashed",
)
ax[i, j].axhline(y=theta_eta, linestyle="--", color="magenta")
ax[i, j].text(
    s2y(SW.t[0][-1]) / 1e9,
    theta_eta,
    "Nominal",
    ha="right",
    va="bottom",
    color="magenta",
)
fig.colorbar(
    p, ax=ax[i, j], label="$E_{\Phi,b}$ ($\mathrm{MW.K^{-1}}$)", location="top"
)
ax[i, j].set_ylabel("$m_\mu$")
ax[i, j].set_ylim(
    [
        np.min(SW.sw_val[~np.isnan((SW.t * filt)[:, 0])]),
        np.max(SW.sw_val[~np.isnan((SW.t * filt)[:, 0])]),
    ]
)

i, j = 0, 1
mask_core = np.where(SW.L_OC > 0, 1, np.nan)
p = ax[i, j].pcolormesh(
    s2y(SW.t[t_idx]) / 1e9,
    SW.sw_val,
    SW.E_PHI_core_S2020 * mask_core / 1e6 * filt,
    cmap="RdBu",
    shading="auto",
    norm=mpl.colors.SymLogNorm(
        linthresh=2e3,
        vmin=-np.nanmax(np.abs(SW.E_PHI_core_S2020 * mask_core / 1e6 * filt)),
        vmax=+np.nanmax(np.abs(SW.E_PHI_core_S2020 * mask_core / 1e6 * filt)),
    ),
    rasterized=True,
)
ax[i, j].contour(
    s2y(t_m) / 1e9,
    sw_val_m,
    SW.E_PHI_core_S2020 * mask_core / 1e6 * filt,
    levels=[0],
    colors="lime",
    linestyles="dashed",
)
ax[i, j].axhline(y=theta_eta, linestyle="--", color="magenta")
ax[i, j].text(
    s2y(SW.t[0][-1]) / 1e9,
    theta_eta,
    "Nominal",
    ha="right",
    va="bottom",
    color="magenta",
)
fig.colorbar(
    p, ax=ax[i, j], label="$E_{\Phi,c}$ ($\mathrm{MW.K^{-1}}$)", location="top"
)
ax[i, j].set_ylim(
    [
        np.min(SW.sw_val[~np.isnan((SW.t * filt)[:, 0])]),
        np.max(SW.sw_val[~np.isnan((SW.t * filt)[:, 0])]),
    ]
)

ax_inset_b = fig.add_axes([0.75, 0.73, 0.21, 0.105])
ax_inset_b.plot(
    SW.sw_val,
    SW.k_core_min,
    "k",
)
ax_inset_b.set_xlabel("$m_\mu$", fontsize="small", labelpad=0)
ax_inset_b.set_ylabel(
    "$k_{c,\\mathrm{max}}$ ($\\mathrm{W.m^{-1}.K^{-1}}$)", fontsize="small"
)
ax_inset_b.set_yscale("log")
ax_inset_b.set_xlim(
    [
        np.min(SW.sw_val[~np.isnan((SW.t * filt)[:, 0])]),
        np.max(SW.sw_val[~np.isnan((SW.t * filt)[:, 0])]),
    ]
)
ax_inset_b.grid()
ax_inset_b.tick_params(axis="both", which="major", labelsize="small")

i, j = 1, 0
p = ax[i, j].pcolormesh(
    s2y(SW.t[t_idx]) / 1e9,
    SW.sw_val,
    SW.Rm_S_BMO_S2020 * mask_BMO * filt,
    cmap="magma_r",
    shading="auto",
    rasterized=True,
    vmin=0,
)
ax[i, j].contour(
    s2y(t_m) / 1e9,
    sw_val_m,
    SW.Rm_S_BMO_S2020 * mask_BMO * filt,
    levels=[SW.param[0].Rm_crit_BMO],
    colors="lime",
    linestyles="dashed",
)
ax[i, j].axhline(y=theta_eta, linestyle="--", color="magenta")
ax[i, j].text(
    s2y(SW.t[0][-1]) / 1e9,
    theta_eta,
    "Nominal",
    ha="right",
    va="bottom",
    color="magenta",
)
fig.colorbar(p, ax=ax[i, j], label="$R_{m_b}$", location="top")
ax[i, j].set_ylabel("$m_\mu$")
ax[i, j].set_ylim(
    [
        np.min(SW.sw_val[~np.isnan((SW.t * filt)[:, 0])]),
        np.max(SW.sw_val[~np.isnan((SW.t * filt)[:, 0])]),
    ]
)

ax_inset_c = fig.add_axes([0.285, 0.417, 0.21, 0.105])
ax_inset_c.plot(
    SW.sw_val,
    SW.sigma_BMO_min,
    "k",
)
ax_inset_c.set_xlabel("$m_\mu$", fontsize="small", labelpad=0)
ax_inset_c.set_ylabel(
    "$\\sigma_{b,\\mathrm{min}}$ ($\\mathrm{S.m^{-1}}$)", fontsize="small"
)
ax_inset_c.set_xlim(
    [
        np.min(SW.sw_val[~np.isnan((SW.t * filt)[:, 0])]),
        np.max(SW.sw_val[~np.isnan((SW.t * filt)[:, 0])]),
    ]
)
ax_inset_c.grid()
ax_inset_c.tick_params(axis="both", which="major", labelsize="small")

i, j = 1, 1
p = ax[i, j].pcolormesh(
    s2y(SW.t[t_idx]) / 1e9,
    SW.sw_val,
    SW.Rm_S_core_S2020 * filt,
    cmap="magma_r",
    shading="auto",
    rasterized=True,
    vmin=0,
)
ax[i, j].contour(
    s2y(t_m) / 1e9,
    sw_val_m,
    SW.Rm_S_core_S2020 * filt,
    levels=[SW.param[0].Rm_crit_core],
    colors="lime",
    linestyles="dashed",
)
ax[i, j].axhline(y=theta_eta, linestyle="--", color="magenta")
ax[i, j].text(
    s2y(SW.t[0][-1]) / 1e9,
    theta_eta,
    "Nominal",
    ha="right",
    va="bottom",
    color="magenta",
)
fig.colorbar(p, ax=ax[i, j], label="$R_{m_c}$", location="top")
ax[i, j].set_ylim(
    [
        np.min(SW.sw_val[~np.isnan((SW.t * filt)[:, 0])]),
        np.max(SW.sw_val[~np.isnan((SW.t * filt)[:, 0])]),
    ]
)

i, j = 2, 0
p = ax[i, j].pcolormesh(
    s2y(SW.t[t_idx]) / 1e9,
    SW.sw_val,
    SW.BS_S_BMO_cst_S2020
    * np.where(SW.Rm_S_BMO_S2020 > SW.param[0].Rm_crit_BMO, 1, np.nan)
    * 1e6
    * filt,
    cmap="cividis_r",
    shading="auto",
    rasterized=True,
    vmin=0,
)
ax[i, j].axhline(y=theta_eta, linestyle="--", color="magenta")
ax[i, j].text(
    s2y(SW.t[0][-1]) / 1e9,
    theta_eta,
    "Nominal",
    ha="right",
    va="bottom",
    color="magenta",
)
fig.colorbar(p, ax=ax[i, j], label="$B_{P,b}$ ($\mu\mathrm{T}$)", location="top")
ax[i, j].set_xlabel("$t$ ($\mathrm{Gyr}$)")
ax[i, j].set_ylabel("$m_\mu$")
ax[i, j].set_ylim(
    [
        np.min(SW.sw_val[~np.isnan((SW.t * filt)[:, 0])]),
        np.max(SW.sw_val[~np.isnan((SW.t * filt)[:, 0])]),
    ]
)

i, j = 2, 1
p = ax[i, j].pcolormesh(
    s2y(SW.t[t_idx]) / 1e9,
    SW.sw_val,
    SW.BS_S_core_cst_S2020
    * np.where(SW.Rm_S_core_S2020 > SW.param[0].Rm_crit_core, 1, np.nan)
    * 1e6
    * filt,
    cmap="cividis_r",
    shading="auto",
    rasterized=True,
    vmin=0,
)
ax[i, j].axhline(y=theta_eta, linestyle="--", color="magenta")
ax[i, j].text(
    s2y(SW.t[0][-1]) / 1e9,
    theta_eta,
    "Nominal",
    ha="right",
    va="bottom",
    color="magenta",
)
fig.colorbar(p, ax=ax[i, j], label="$B_{P,c}$ ($\mu\mathrm{T}$)", location="top")
ax[i, j].set_xlabel("$t$ ($\mathrm{Gyr}$)")
ax[i, j].set_ylim(
    [
        np.min(SW.sw_val[~np.isnan((SW.t * filt)[:, 0])]),
        np.max(SW.sw_val[~np.isnan((SW.t * filt)[:, 0])]),
    ]
)

subplots_label(ax, colorbar=True)
if save_fig:
    fig.savefig(save_path + "/SI_sensitivity_theta_eta.pdf")
